<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Applied Machine Learning Using mlr3 in R - 3&nbsp; Evaluation and Benchmarking</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../chapters/chapter4/hyperparameter_optimization.html" rel="next">
<link href="../../chapters/chapter2/data_and_basic_modeling.html" rel="prev">
<link href="../../Figures/favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><style>html{ scroll-behavior: smooth; }</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter2/data_and_basic_modeling.html">Fundamentals</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter3/evaluation_and_benchmarking.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">Applied Machine Learning Using mlr3 in R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/mlr-org/mlr3book/tree/main/book/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../Applied-Machine-Learning-Using-mlr3-in-R.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter1/introduction_and_overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction and Overview</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter3/evaluation_and_benchmarking.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">Tuning and Feature Selection</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter5/advanced_tuning_methods_and_black_box_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Advanced Tuning Methods and Black Box Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter6/feature_selection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Feature Selection</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Pipelines and Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter7/sequential_pipelines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sequential Pipelines</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter8/non-sequential_pipelines_and_tuning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Non-sequential Pipelines and Tuning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter9/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter10/advanced_technical_aspects_of_mlr3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Advanced Technical Aspects of mlr3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter11/large-scale_benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Large-Scale Benchmarking</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter12/model_interpretation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Model Interpretation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter13/beyond_regression_and_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Beyond Regression and Classification</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/chapter14/algorithmic_fairness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Algorithmic Fairness</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">References</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/solutions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Solutions to exercises</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/tasks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Tasks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/overview-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Overview Tables</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../chapters/appendices/errata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Errata</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li><a href="#sec-holdout-scoring" id="toc-sec-holdout-scoring" class="nav-link active" data-scroll-target="#sec-holdout-scoring"><span class="header-section-number">3.1</span> Holdout and Scoring</a></li>
  <li>
<a href="#sec-resampling" id="toc-sec-resampling" class="nav-link" data-scroll-target="#sec-resampling"><span class="header-section-number">3.2</span> Resampling</a>
  <ul class="collapse">
<li><a href="#sec-resampling-construct" id="toc-sec-resampling-construct" class="nav-link" data-scroll-target="#sec-resampling-construct"><span class="header-section-number">3.2.1</span> Constructing a Resampling Strategy</a></li>
  <li><a href="#sec-resampling-exec" id="toc-sec-resampling-exec" class="nav-link" data-scroll-target="#sec-resampling-exec"><span class="header-section-number">3.2.2</span> Resampling Experiments</a></li>
  <li><a href="#sec-resampling-inspect" id="toc-sec-resampling-inspect" class="nav-link" data-scroll-target="#sec-resampling-inspect"><span class="header-section-number">3.2.3</span> ResampleResult Objects</a></li>
  <li><a href="#sec-resamp-custom" id="toc-sec-resamp-custom" class="nav-link" data-scroll-target="#sec-resamp-custom"><span class="header-section-number">3.2.4</span> Custom Resampling</a></li>
  <li><a href="#sec-strat-group" id="toc-sec-strat-group" class="nav-link" data-scroll-target="#sec-strat-group"><span class="header-section-number">3.2.5</span> Stratification and Grouping</a></li>
  </ul>
</li>
  <li>
<a href="#sec-benchmarking" id="toc-sec-benchmarking" class="nav-link" data-scroll-target="#sec-benchmarking"><span class="header-section-number">3.3</span> Benchmarking</a>
  <ul class="collapse">
<li><a href="#sec-bm-design" id="toc-sec-bm-design" class="nav-link" data-scroll-target="#sec-bm-design"><span class="header-section-number">3.3.1</span> benchmark()</a></li>
  <li><a href="#sec-bm-resamp" id="toc-sec-bm-resamp" class="nav-link" data-scroll-target="#sec-bm-resamp"><span class="header-section-number">3.3.2</span> BenchmarkResult Objects</a></li>
  </ul>
</li>
  <li>
<a href="#sec-roc" id="toc-sec-roc" class="nav-link" data-scroll-target="#sec-roc"><span class="header-section-number">3.4</span> Evaluation of Binary Classifiers</a>
  <ul class="collapse">
<li><a href="#confusion-matrix" id="toc-confusion-matrix" class="nav-link" data-scroll-target="#confusion-matrix"><span class="header-section-number">3.4.1</span> Confusion Matrix</a></li>
  <li><a href="#sec-roc-space" id="toc-sec-roc-space" class="nav-link" data-scroll-target="#sec-roc-space"><span class="header-section-number">3.4.2</span> ROC Analysis</a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">3.5</span> Conclusion</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">3.6</span> Exercises</a></li>
  <li><a href="#citation" id="toc-citation" class="nav-link" data-scroll-target="#citation"><span class="header-section-number">3.7</span> Citation</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter3/evaluation_and_benchmarking.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter3/evaluation_and_benchmarking.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../chapters/chapter2/data_and_basic_modeling.html">Fundamentals</a></li><li class="breadcrumb-item"><a href="../../chapters/chapter3/evaluation_and_benchmarking.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></a></li></ol></nav><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-performance" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Evaluation and Benchmarking</span></span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><p><strong>Giuseppe Casalicchio</strong> <br><em>Ludwig-Maximilians-Universität München, and Munich Center for Machine Learning (MCML), and Essential Data Science Training GmbH</em></p>
<p><strong>Lukas Burk</strong> <br><em>Ludwig-Maximilians-Universität München, and Leibniz Institute for Prevention Research and Epidemiology - BIPS, and Munich Center for Machine Learning (MCML)</em> <br><br></p>
<div class="page-columns page-full"><p>A supervised machine learning model can only be deployed in practice if it has a good generalization performance, which means it generalizes well to new, unseen data. Accurate estimation of the generalization performance is crucial for many aspects of machine learning application and research – whether we want to fairly compare a novel algorithm with established ones or to find the best algorithm for a particular task. The concept of performance estimation provides information on how well a model will generalize to new data and plays an important role in the context of model comparison (<a href="#sec-benchmarking" class="quarto-xref"><span>Section 3.3</span></a>), model selection, and hyperparameter tuning (<a href="../chapter4/hyperparameter_optimization.html" class="quarto-xref"><span>Chapter 4</span></a>).</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Generalization Performance</span></div></div>
<p>Assessing the generalization performance of a model begins with selecting a performance measure that is appropriate for our given task and evaluation goal. As we have seen in <a href="../chapter2/data_and_basic_modeling.html#sec-eval" class="quarto-xref"><span>Section 2.3</span></a>, performance measures typically compute a numeric score indicating how well the model predictions match the ground truth (though some technical measures were seen in <a href="../chapter2/data_and_basic_modeling.html#sec-basics-measures-tech" class="quarto-xref"><span>Section 2.3.3</span></a>). Once we have decided on a performance measure, the next step is to adopt a strategy that defines how to use the available data to estimate the generalization performance. Using the same data to train and test a model is a bad strategy as it would lead to an overly optimistic performance estimate. For example, a model that is overfitted (fit too closely to the data) could make perfect predictions on training data simply by memorizing it and then only make random guesses for new data. In <a href="../chapter2/data_and_basic_modeling.html#sec-basics-partition" class="quarto-xref"><span>Section 2.2.1.1</span></a> we introduced <a href="https://mlr3.mlr-org.com/reference/partition.html"><code>partition()</code></a>, which splits a dataset into training data – data for training the model – and test data – data for testing the model and estimating the generalization performance, this is known as the holdout strategy (<a href="#sec-holdout-scoring" class="quarto-xref"><span>Section 3.1</span></a>) and is where we will begin this chapter. We will then consider more advanced strategies for assessing the generalization performance (<a href="#sec-resampling" class="quarto-xref"><span>Section 3.2</span></a>), look at robust methods for comparing models (<a href="#sec-benchmarking" class="quarto-xref"><span>Section 3.3</span></a>), and finally will discuss specialized performance measures for binary classification (<a href="#sec-roc" class="quarto-xref"><span>Section 3.4</span></a>). For an in-depth overview of measures and performance estimation, we recommend <span class="citation" data-cites="japkowicz2011evaluating">Japkowicz and Shah (<a href="../references.html#ref-japkowicz2011evaluating" role="doc-biblioref">2011</a>)</span>.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Resampling Does Not Avoid Model Overfitting
</div>
</div>
<div class="callout-body-container callout-body">
<p>A common <strong>misunderstanding</strong> is that holdout and other more advanced resampling strategies can prevent model overfitting. In fact, these methods just make overfitting visible as we can separately evaluate train/test performance. Resampling strategies also allow us to make (nearly) unbiased estimations of the generalization error.</p>
</div>
</div>
<section id="sec-holdout-scoring" class="level2 page-columns page-full" data-number="3.1"><h2 data-number="3.1" class="anchored" data-anchor-id="sec-holdout-scoring">
<span class="header-section-number">3.1</span> Holdout and Scoring</h2>
<div class="page-columns page-full"><p>An important goal of ML is to learn a model that can then be used to make predictions about new data. For this model to be as accurate as possible, we would ideally train it on as much data as is available. However, data is limited and as we have discussed we cannot train and test a model on the same data. In practice, one would usually create an intermediate model, which is trained on a subset of the available data and then tested on the remainder of the data. The performance of this intermediate model, obtained by comparing the model predictions to the ground truth, is an estimate of the generalization performance of the final model, which is the model fitted on all data.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Intermediate Model</span></div></div>
<div class="page-columns page-full"><p>The holdout strategy is a simple method to create this split between training and testing datasets, whereby the original data is split into two datasets using a defined ratio. Ideally, the training dataset should be as large as possible so the intermediate model represents the final model as well possible. If the training data is too small, the intermediate model is unlikely to perform as well as the final model, resulting in a pessimistically biased performance estimate. On the other hand, if the training data is too large, then we will not have a reliable estimate of the generalization performance due to high variance resulting from small test data. As a rule of thumb, it is common to use 2/3 of the data for training and 1/3 for testing as this provides a reasonable trade-off between bias and variance of the generalization performance estimate <span class="citation" data-cites="kohavi1995 dobbin2011">(<a href="../references.html#ref-kohavi1995" role="doc-biblioref">Kohavi 1995</a>; <a href="../references.html#ref-dobbin2011" role="doc-biblioref">Dobbin and Simon 2011</a>)</span>.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Holdout</span></div></div>
<p>In <a href="../chapter2/data_and_basic_modeling.html" class="quarto-xref"><span>Chapter 2</span></a>, we used <a href="https://mlr3.mlr-org.com/reference/partition.html"><code>partition()</code></a> to apply the holdout method to a <a href="https://mlr3.mlr-org.com/reference/Task.html"><code>Task</code></a> object. To recap, let us split <code>tsk("penguins")</code> with a 2/3 holdout (default split):</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_penguins</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">splits</span> <span class="op">=</span> <span class="fu">partition</span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">)</span></span>
<span><span class="va">lrn_rpart</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.rpart"</span><span class="op">)</span></span>
<span><span class="va">lrn_rpart</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">splits</span><span class="op">$</span><span class="va">train</span><span class="op">)</span></span>
<span><span class="va">prediction</span> <span class="op">=</span> <span class="va">lrn_rpart</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">splits</span><span class="op">$</span><span class="va">test</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now estimate the generalization performance of a final model by evaluating the quality of the predictions from our intermediate model. As we have seen in <a href="../chapter2/data_and_basic_modeling.html#sec-eval" class="quarto-xref"><span>Section 2.3</span></a>, this is simply a case of choosing one or more measures and passing them to the <code>$score()</code> function. So to estimate the accuracy of our final model we would pass the accuracy measure to our intermediate model:</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">prediction</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.acc 
     0.9558 </code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Permuting Observations for Performance Estimation
</div>
</div>
<div class="callout-body-container callout-body">
<p>When splitting data it is essential to permute observations before, to remove any information that is encoded in data ordering. The order of data is often informative in real-world datasets, for example hospital data will likely be ordered by time of patient admission. In <code>tsk("penguins")</code>, the data is ordered such that the first 152 rows all have the label ‘Adelie’, the next 68 have the label ‘Chinstrap’, and the final 124 have the label ‘Gentoo’; so if we did not permute the data we could end up with a model that is only trained on one or two species.</p>
<p><code>partition()</code> and all resampling strategies discussed below automatically randomly split the data to prevent any biases (so do not forget to set a seed for reproducibility). Data <em>within</em> each set may still be ordered because of implementation details, but this is not a problem as long as the data is shuffled between sets.</p>
</div>
</div>
<p>Many performance measures are based on ‘decomposable’ losses, which means they compute the differences between the predicted values and ground truth values first on an observation level and then aggregate the individual loss values over the test set into a single numeric score. For example, the classification accuracy compares whether the predicted values from the <code>response</code> column have the same value as the ground truth values from the <code>truth</code> column of the <a href="https://mlr3.mlr-org.com/reference/Prediction.html"><code>Prediction</code></a> object. Hence, for each observation, the decomposable loss takes either value <code>1</code> (if <code>response</code> and <code>truth</code> have the same value) or <code>0</code> otherwise. The <code>$score()</code> method summarizes these individual loss values into a an average value – the percentage where our prediction was correct. Other performance measures that are not decomposable instead act on a set of observations, we will return to this in detail when we look at the AUC measure in <a href="#sec-roc" class="quarto-xref"><span>Section 3.4</span></a>. <a href="#fig-score" class="quarto-xref">Figure&nbsp;<span>3.1</span></a> illustrates the input-output behavior of the <code>$score()</code> method, we will return to this when we turn to more complex evaluation strategies.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-score" class="quarto-figure quarto-figure-center quarto-float anchored" alt="A funnel-shaped diagram where the far left box shows the output from a classification prediction object with row_ids, truth, and response columns. Next to this is a box that just says '$score()', which then passes to the right in a funnel shape to a box that says 'classif.acc 0.920354'.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-score-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-3.svg" class="img-fluid figure-img" style="width:80.0%" alt="A funnel-shaped diagram where the far left box shows the output from a classification prediction object with row_ids, truth, and response columns. Next to this is a box that just says '$score()', which then passes to the right in a funnel shape to a box that says 'classif.acc 0.920354'.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-score-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: Illustration of the <code>$score()</code> method which aggregates predictions of multiple observations contained in a prediction object into a single numeric score
</figcaption></figure>
</div>
</div>
</div>
</section><section id="sec-resampling" class="level2 page-columns page-full" data-number="3.2"><h2 data-number="3.2" class="anchored" data-anchor-id="sec-resampling">
<span class="header-section-number">3.2</span> Resampling</h2>
<p>Resampling strategies repeatedly split all available data into multiple training and test sets, with one repetition corresponding to what is called a ‘resampling iteration’ in <a href="https://mlr3.mlr-org.com"><code>mlr3</code></a>. An intermediate model is then trained on each training set and the test set is used to measure the performance in each resampling iteration. The generalization performance is finally estimated by aggregating the performance scores over multiple resampling iterations (<a href="#fig-ml-abstraction" class="quarto-xref">Figure&nbsp;<span>3.2</span></a>). By repeating the data splitting process, data points are repeatedly used for both training and testing, allowing more efficient use of all available data for performance estimation. Furthermore, a high number of resampling iterations can reduce the variance in our scores and thus result in a more reliable performance estimate. This means that the performance estimate is less likely to be affected by an ‘unlucky’ split (e.g., a split that does not reflect the original data distribution).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-ml-abstraction" class="quarto-figure quarto-figure-center quarto-float anchored" alt="A flowchart-like diagram with 3 overlapping boxes. Left box has the caption 'Data splitting / resampling process', upper right box has caption 'Learning process', and lower right box has caption 'Evaluation process'. The process starts in the left box with 'Data' and an arrow to 'Resampling Strategy', which separates into two elements stacked vertically: 'Train Set(s)' above and 'Test Set(s)' below. The 'Train set(s)' element leads to a 'Learner' box, which is inside the larger 'Learning Process' box. A box that says 'Hyperparameters' also sits within the 'Learning Process' and is connected with an arrow also pointing to 'Learner'. An arrow points from the 'Learner' to a stack of 'Intermediate Model(s)'. One thick arrow goes down into the yellow box to a stack of 'Prediction(s)'. An arrow goes from there to 'Performance measure'. The 'Test set(s)' from earlier also have an arrow to 'Performance measure'. From there, a thick arrow goes to 'Performance Value(s)', which has a final dashed arrow to 'Aggregated Performance'.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-ml-abstraction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-4.svg" class="img-fluid figure-img" style="width:100.0%" alt="A flowchart-like diagram with 3 overlapping boxes. Left box has the caption 'Data splitting / resampling process', upper right box has caption 'Learning process', and lower right box has caption 'Evaluation process'. The process starts in the left box with 'Data' and an arrow to 'Resampling Strategy', which separates into two elements stacked vertically: 'Train Set(s)' above and 'Test Set(s)' below. The 'Train set(s)' element leads to a 'Learner' box, which is inside the larger 'Learning Process' box. A box that says 'Hyperparameters' also sits within the 'Learning Process' and is connected with an arrow also pointing to 'Learner'. An arrow points from the 'Learner' to a stack of 'Intermediate Model(s)'. One thick arrow goes down into the yellow box to a stack of 'Prediction(s)'. An arrow goes from there to 'Performance measure'. The 'Test set(s)' from earlier also have an arrow to 'Performance measure'. From there, a thick arrow goes to 'Performance Value(s)', which has a final dashed arrow to 'Aggregated Performance'.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ml-abstraction-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.2: A general abstraction of the performance estimation process. The available data is (repeatedly) split into training data and test data (data splitting / resampling process). The learner is trained on each training dataset and produces intermediate models (learning process). Each intermediate model makes predictions based on the features in the test data. The performance measure compares these predictions with the ground truth from the test data and computes a performance value for each test dataset. All performance values are aggregated into a scalar value to estimate the generalization performance (evaluation process).
</figcaption></figure>
</div>
</div>
</div>
<p>A variety of resampling strategies exist, each with its advantages and disadvantages, which depend on the number of available samples, the task complexity, and the type of model.</p>
<div class="page-columns page-full"><p>A very common strategy is k-fold cross-validation (CV), which randomly partitions the data into <span class="math inline">\(k\)</span> non-overlapping subsets, called folds (<a href="#fig-cv-illustration" class="quarto-xref">Figure&nbsp;<span>3.3</span></a>). The <span class="math inline">\(k\)</span> models are always trained on <span class="math inline">\(k-1\)</span> of the folds, with the remaining fold being used as test data; this process is repeated until each fold has acted exactly once as test set. Finally, the <span class="math inline">\(k\)</span> performance estimates from each fold are aggregated, usually by averaging. CV guarantees that each observation will be used exactly once in a test set, making efficient use of the available data for performance estimation. Common values for <span class="math inline">\(k\)</span> are 5 and 10, meaning each training set will consist of 4/5 or 9/10 of the original data, respectively. Several variations of CV exist, including repeated k-fold cross-validation where the k-fold process is repeated multiple times, and leave-one-out cross-validation (LOO-CV) where the number of folds is equal to the number of observations, leading to the test set in each fold consisting of only one observation.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Cross-validation</span></div></div>
<div class="page-columns page-full"><p>Subsampling and bootstrapping are two related resampling strategies. Subsampling randomly selects a given ratio (4/5 and 9/10 are common) of the data for the training dataset where each observation in the dataset is drawn <em>without replacement</em> from the original dataset. The model is trained on this data and then tested on the remaining data, and this process is repeated <span class="math inline">\(k\)</span> times. This differs from k-fold CV as the subsets of test data may be overlapping. Bootstrapping follows the same process as subsampling but data is drawn <em>with replacement</em> from the original dataset. Usually the number of bootstrap samples equals the size of the original dataset. This means an observation could be selected multiple times (and thus duplicated) in the training data (but never more than once per test dataset). On average, <span class="math inline">\(1 - e^{-1} \approx 63.2\%\)</span> of the data points will be contained in the training set during bootstrapping, referred to as “in-bag” samples (the other 36.8% are known as “out-of-bag” samples).</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Subsampling</span></div></div>
<p>Note that terminology regarding resampling strategies is not consistent across the literature, for example, subsampling is sometimes referred to as “repeated holdout” or “Monte Carlo cross-validation”.</p>
<p>The choice of the resampling strategy usually depends on the specific task at hand and the goals of the performance assessment, but some rules of thumb are available. If the available data is fairly small (<span class="math inline">\(N \leq 500\)</span>), repeated cross-validation with a large number of repetitions can be used to keep the variance of the performance estimates low (10 folds and 10 repetitions is a good place to start). Traditionally, LOO-CV has also been recommended for these small sample size regimes, but this estimation scheme is quite expensive (except in special cases where computational shortcuts exist) and (counterintuitively) suffers from quite high variance. Furthermore, LOO-CV is also problematic in imbalanced binary classification tasks as concepts such as stratification (<a href="#sec-strat-group" class="quarto-xref"><span>Section 3.2.5</span></a>) cannot be applied. For the <span class="math inline">\(500 \leq N \leq 50000\)</span> range, 5- to 10-fold CV is generally recommended. In general, the larger the dataset, the fewer splits are required, yet sample-size issues can still occur, e.g., due to imbalanced data. For settings where one is more interested in proper inference (such as through statistical performance tests or confidence intervals) than bare point estimators of performance, bootstrapping and subsampling are often considered, usually with a higher number of iterations. Bootstrapping has become less common, as having repeated observations in training data can lead to problems in some machine learning setups, especially when combined with model selection methods and nested resampling (as duplicated observations can then end up simultaneously in training and test sets in nested schemes). Also note that in all of these common and simple schemes, resampling performance estimates are not independent, as models are fitted on overlapping training data, making proper inference less than trivial, but a proper treatment of these issues is out of scope for us here. For further details and critical discussion we refer to the literature, e.g., <span class="citation" data-cites="molinaro2005prediction">Molinaro, Simon, and Pfeiffer (<a href="../references.html#ref-molinaro2005prediction" role="doc-biblioref">2005</a>)</span>, <span class="citation" data-cites="kim2009estimating">Kim (<a href="../references.html#ref-kim2009estimating" role="doc-biblioref">2009</a>)</span>, and <span class="citation" data-cites="bischl2012resampling">Bischl et al. (<a href="../references.html#ref-bischl2012resampling" role="doc-biblioref">2012</a>)</span>.</p>
<!-- Source: https://docs.google.com/presentation/d/1BJXJ365C9TWelojV93IeQJAtEiD3uZMFSfkhzgYH-n8/edit?usp=sharing -->
<div class="cell">
<div class="cell-output-display">
<div id="fig-cv-illustration" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Complex flow chart in roughly three rows. Top row (Iteration 1) shows Dtrain split into two light blue boxes representing training data and pointing to a 'Learner', which points to a 'Model'. A dark blue box representing test data points to the same 'Model' as well as 'Measure'. 'Model' points to 'Prediction' which also points to 'Measure', which then points to 'Performance', which has an arrow to 'Averaged Performance'. In rows two and three the same process is inferred except with different boxes in dark and light blue so that each box has been dark blue exactly once across all three iterations.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-cv-illustration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-6.svg" class="img-fluid figure-img" style="width:100.0%" alt="Complex flow chart in roughly three rows. Top row (Iteration 1) shows Dtrain split into two light blue boxes representing training data and pointing to a 'Learner', which points to a 'Model'. A dark blue box representing test data points to the same 'Model' as well as 'Measure'. 'Model' points to 'Prediction' which also points to 'Measure', which then points to 'Performance', which has an arrow to 'Averaged Performance'. In rows two and three the same process is inferred except with different boxes in dark and light blue so that each box has been dark blue exactly once across all three iterations.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cv-illustration-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.3: Illustration of a three-fold cross-validation.
</figcaption></figure>
</div>
</div>
</div>
<p>In the rest of this section, we will go through querying and constructing resampling strategies in <code>mlr3</code>, instantiating train-test splits, and then performing resampling on learners.</p>
<section id="sec-resampling-construct" class="level3 page-columns page-full" data-number="3.2.1"><h3 data-number="3.2.1" class="anchored" data-anchor-id="sec-resampling-construct">
<span class="header-section-number">3.2.1</span> Constructing a Resampling Strategy</h3>
<p>All implemented resampling strategies are stored in the <a href="https://mlr3.mlr-org.com/reference/mlr_resamplings.html"><code>mlr_resamplings</code></a> dictionary.</p>
<div class="cell">
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">as.data.table</span><span class="op">(</span><span class="va">mlr_resamplings</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>           key                         label        params iters
1:   bootstrap                     Bootstrap ratio,repeats    30
2:      custom                 Custom Splits                  NA
3:   custom_cv Custom Split Cross-Validation                  NA
4:          cv              Cross-Validation         folds    10
5:     holdout                       Holdout         ratio     1
6:    insample           Insample Resampling                   1
7:         loo                 Leave-One-Out                  NA
8: repeated_cv     Repeated Cross-Validation folds,repeats   100
9: subsampling                   Subsampling ratio,repeats    30</code></pre>
</div>
</div>
<p>The <code>params</code> column shows the parameters of each resampling strategy (e.g., the train-test splitting <code>ratio</code> or the number of <code>repeats</code>) and <code>iters</code> displays the number of performed resampling iterations by default.</p>
<div class="page-columns page-full"><p><a href="https://mlr3.mlr-org.com/reference/Resampling.html"><code>Resampling</code></a> objects can be constructed by passing the strategy ‘key’ to the sugar function <a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html"><code>rsmp()</code></a>. For example, to construct the holdout strategy with a 4/5 split (2/3 by default):</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>Resampling</code></span><span class="margin-aside"><code>rsmp()</code></span></div></div>
<div class="cell">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">rsmp</span><span class="op">(</span><span class="st">"holdout"</span>, ratio <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ResamplingHoldout&gt;: Holdout
* Iterations: 1
* Instantiated: FALSE
* Parameters: ratio=0.8</code></pre>
</div>
</div>
<p>Parameters for objects inheriting from <code>Resampling</code> work in the same way as measures and learners and can be set, retrieved, and updated accordingly:</p>
<div class="cell">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># three-fold CV</span></span>
<span><span class="va">cv3</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co"># Subsampling with 3 repeats and 9/10 ratio</span></span>
<span><span class="va">ss390</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"subsampling"</span>, repeats <span class="op">=</span> <span class="fl">3</span>, ratio <span class="op">=</span> <span class="fl">0.9</span><span class="op">)</span></span>
<span><span class="co"># 2-repeats 5-fold CV</span></span>
<span><span class="va">rcv25</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"repeated_cv"</span>, repeats <span class="op">=</span> <span class="fl">2</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="page-columns page-full"><p>When a <code>"Resampling"</code> object is constructed, it is simply a definition for how the data splitting process will be performed on the task when running the resampling strategy. However, it is possible to manually instantiate a resampling strategy, i.e., generate all train-test splits, by calling the <code>$instantiate()</code> method on a given task. So carrying on our <code>tsk("penguins")</code> example we can instantiate the three-fold CV object and then view the row indices of the data selected for training and testing each fold using <code>$train_set()</code> and <code>$test_set()</code> respectively:</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>$instantiate()</code></span></div></div>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">cv3</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">)</span></span>
<span><span class="co"># first 5 observations in first training set</span></span>
<span><span class="va">cv3</span><span class="op">$</span><span class="fu">train_set</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  1  9 21 22 23</code></pre>
</div>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># first 5 observations in third test set</span></span>
<span><span class="va">cv3</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  2  3  5 10 12</code></pre>
</div>
</div>
<p>When the aim is to fairly compare multiple learners, best practice dictates that all learners being compared use the same training data to build a model and that they use the same test data to evaluate the model performance. Resampling strategies are instantiated automatically for you when using the <code>resample()</code> method, which we will discuss next. Therefore, manually instantiating resampling strategies is rarely required but might be useful for debugging or digging deeper into a model’s performance.</p>
</section><section id="sec-resampling-exec" class="level3 page-columns page-full" data-number="3.2.2"><h3 data-number="3.2.2" class="anchored" data-anchor-id="sec-resampling-exec">
<span class="header-section-number">3.2.2</span> Resampling Experiments</h3>
<div class="page-columns page-full"><p>The <a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a> function takes a given <code>Task</code>, <code>Learner</code>, and <a href="https://mlr3.mlr-org.com/reference/Resampling.html"><code>Resampling</code></a> object to run the given resampling strategy. <code>resample()</code> repeatedly fits a model on training sets, makes predictions on the corresponding test sets and stores them in a <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a> object, which contains all the information needed to estimate the generalization performance.</p><div class="no-row-height column-margin column-container"><span class="margin-aside"><code>resample()</code></span><span class="margin-aside"><code>ResampleResult</code></span></div></div>
<div class="cell">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">lrn_rpart</span>, <span class="va">cv3</span><span class="op">)</span></span>
<span><span class="va">rr</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ResampleResult&gt; with 3 resampling iterations
  task_id    learner_id resampling_id iteration warnings errors
 penguins classif.rpart            cv         1        0      0
 penguins classif.rpart            cv         2        0      0
 penguins classif.rpart            cv         3        0      0</code></pre>
</div>
</div>
<p>Each row of the output corresponds to one of the three iterations/folds. As with <code>Prediction</code> objects, we can calculate the score <em>for each iteration</em> with <code>$score()</code>:</p>
<div class="cell">
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">acc</span> <span class="op">=</span> <span class="va">rr</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">acc</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration classif.ce
1:         1    0.06087
2:         2    0.04348
3:         3    0.06140</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Evaluating Train Sets
</div>
</div>
<div class="callout-body-container callout-body">
<p>By default, <code>$score()</code> evaluates the performance in the <em>test</em> sets in each iteration, however, you could evaluate the <em>train</em> set performance with <code>$score(predict_sets = "train")</code>.</p>
</div>
</div>
<div class="page-columns page-full"><p>While <code>$score()</code> returns the performance in each evaluation, <code>$aggregate()</code>, returns the aggregated score across all resampling iterations.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">$aggregate()</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
   0.05525 </code></pre>
</div>
</div>
<p>By default, the majority of measures will aggregate scores using a macro average, which first calculates the measure in each resampling iteration separately, and then averages these scores across all iterations. However, it is also possible to aggregate scores using a micro average, which pools predictions across resampling iterations into one <a href="https://mlr3.mlr-org.com/reference/Prediction.html"><code>Prediction</code></a> object and then computes the measure on this directly:</p>
<div class="cell">
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.ce"</span>, average <span class="op">=</span> <span class="st">"micro"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
   0.05523 </code></pre>
</div>
</div>
<p>We can see a <em>small</em> difference between the two methods. Classification error is a decomposable loss (<a href="#sec-holdout-scoring" class="quarto-xref"><span>Section 3.1</span></a>), in fact, if the test sets all had the same size then the micro and macro methods would be identical (see box below). For errors like AUC, which are defined across the set of observations, the difference between micro- and macro-averaging will be larger. The default type of aggregation method can be found by querying the <code>$average</code> field of a <a href="https://mlr3.mlr-org.com/reference/Measure.html"><code>Measure</code></a> object.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Macro- and Micro-Averaging
</div>
</div>
<div class="callout-body-container callout-body">
<p>As a simple example to explain macro- and micro-averaging, consider the difference between taking the mean of a vector (micro) compared to the mean of two group-wise means (macro):</p>
<div class="cell">
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># macro</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">9</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5.667</code></pre>
</div>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># micro</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">9</span>, <span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.6</code></pre>
</div>
</div>
<p>In the example shown in the main text where we used <code>tsk("penguins")</code>, there is a difference in the classification error between micro and macro methods because the dataset has 344 rows, which is not divisible by three (the number of folds), hence the test sets are not of an equal size.</p>
<p>Note that the terms “macro-averaging” and “micro-averaging” are not used consistently in the literature, and sometimes refer to different concepts, e.g., the way in which the performance is aggregated across classes in a multi-class classification task.</p>
</div>
</div>
<p>The aggregated score returned by <code>$aggregate()</code> estimates the generalization performance of our selected learner on the given task using the resampling strategy defined in the <code>Resampling</code> object. While we are usually interested in this aggregated score, it can be useful to look at the individual performance values of each resampling iteration (as returned by the <code>$score()</code> method) as well, e.g., to see if any of the iterations lead to very different performance results. <a href="#fig-score-aggregate-resampling" class="quarto-xref">Figure&nbsp;<span>3.4</span></a> visualizes the relationship between <code>$score()</code> and <code>$aggregate()</code> for a small example based on the <code>"penguins"</code> task.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-score-aggregate-resampling" class="quarto-figure quarto-figure-center quarto-float anchored" alt="A funnel-shaped diagram. Left: Each resampling iteration contains multiple rows of predictions, with 3 iterations total. Middle: $score() reduces those to one performance score per resampling iteration, which leaves 3 scores. Right: $aggregate() reduces predictions across all resampling iterations to a single performance score.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-score-aggregate-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-5.svg" class="img-fluid figure-img" style="width:100.0%" alt="A funnel-shaped diagram. Left: Each resampling iteration contains multiple rows of predictions, with 3 iterations total. Middle: $score() reduces those to one performance score per resampling iteration, which leaves 3 scores. Right: $aggregate() reduces predictions across all resampling iterations to a single performance score.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-score-aggregate-resampling-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.4: An example of the difference between <code>$score()</code> and <code>$aggregate()</code>: The former aggregates predictions to a single score within each resampling iteration, and the latter aggregates scores across all resampling iterations.
</figcaption></figure>
</div>
</div>
</div>
<p>To visualize the resampling results, you can use the <a href="https://mlr3viz.mlr-org.com/reference/autoplot.ResampleResult.html"><code>autoplot.ResampleResult()</code></a> function to plot scores across folds as boxplots or histograms (<a href="#fig-resamp-viz" class="quarto-xref">Figure&nbsp;<span>3.5</span></a>). Histograms can be useful to visually gauge the variance of the performance results across resampling iterations, whereas boxplots are often used when multiple learners are compared side-by-side (see <a href="#sec-benchmarking" class="quarto-xref"><span>Section 3.3</span></a>).</p>
<div class="cell">
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">lrn_rpart</span>, <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">10</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">rr</span>, measure <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"boxplot"</span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">rr</span>, measure <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"histogram"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-resamp-viz" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-resamp-viz-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-resamp-viz" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-resamp-viz-1" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Left: a boxplot ranging from 0.875 to 1.0 and the interquartile range between 0.925 and 0.7. Right: a histogram with five bars in a roughly normal distribution with mean 0.95, minimum 0.875 and maximum 1.0.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-resamp-viz-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-resamp-viz-1.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-resamp-viz" alt="Left: a boxplot ranging from 0.875 to 1.0 and the interquartile range between 0.925 and 0.7. Right: a histogram with five bars in a roughly normal distribution with mean 0.95, minimum 0.875 and maximum 1.0.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-resamp-viz-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Boxplot of accuracy scores.
</figcaption></figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-resamp-viz" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-resamp-viz-2" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Left: a boxplot ranging from 0.875 to 1.0 and the interquartile range between 0.925 and 0.7. Right: a histogram with five bars in a roughly normal distribution with mean 0.95, minimum 0.875 and maximum 1.0.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-resamp-viz-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-resamp-viz-2.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-resamp-viz" alt="Left: a boxplot ranging from 0.875 to 1.0 and the interquartile range between 0.925 and 0.7. Right: a histogram with five bars in a roughly normal distribution with mean 0.95, minimum 0.875 and maximum 1.0.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-resamp-viz-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Histogram of accuracy scores.
</figcaption></figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-resamp-viz-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.5: Boxplot and Histogram of accuracy scores.
</figcaption></figure>
</div>
</section><section id="sec-resampling-inspect" class="level3" data-number="3.2.3"><h3 data-number="3.2.3" class="anchored" data-anchor-id="sec-resampling-inspect">
<span class="header-section-number">3.2.3</span> ResampleResult Objects</h3>
<p>As well as being useful for estimating the generalization performance, the <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a> object can also be used for model inspection. We can use the <code>$predictions()</code> method to obtain a list of <a href="https://mlr3.mlr-org.com/reference/Prediction.html"><code>Prediction</code></a> objects corresponding to the predictions from each resampling iteration. This can be used to analyze the predictions of individual intermediate models from each resampling iteration. To understand the class better, we use it here to manually compute a macro averaged performance estimate.</p>
<div class="cell">
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># list of prediction objects</span></span>
<span><span class="va">rrp</span> <span class="op">=</span> <span class="va">rr</span><span class="op">$</span><span class="fu">predictions</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co"># print first two</span></span>
<span><span class="va">rrp</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
&lt;PredictionClassif&gt; for 35 observations:
    row_ids     truth  response
          2    Adelie    Adelie
          4    Adelie    Adelie
         11    Adelie    Adelie
---                            
        333 Chinstrap Chinstrap
        334 Chinstrap Chinstrap
        337 Chinstrap Chinstrap

[[2]]
&lt;PredictionClassif&gt; for 35 observations:
    row_ids     truth response
          1    Adelie   Adelie
         21    Adelie   Adelie
         34    Adelie   Adelie
---                           
        309 Chinstrap   Adelie
        317 Chinstrap   Gentoo
        343 Chinstrap   Gentoo</code></pre>
</div>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># macro averaged performance</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">rrp</span>, <span class="kw">function</span><span class="op">(</span><span class="va">.x</span><span class="op">)</span> <span class="va">.x</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.05807</code></pre>
</div>
</div>
<p>The <code>$prediction()</code> method can be used to extract a single <code>Prediction</code> object that combines the predictions of each intermediate model across all resampling iterations. The combined prediction object can, for example, be used to manually compute a micro-averaged performance estimate (see <a href="#sec-resampling-exec" class="quarto-xref"><span>Section 3.2.2</span></a> for how to you can micro-average more conveniently).</p>
<div class="cell">
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">prediction</span> <span class="op">=</span> <span class="va">rr</span><span class="op">$</span><span class="fu">prediction</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">prediction</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;PredictionClassif&gt; for 344 observations:
    row_ids     truth  response
          2    Adelie    Adelie
          4    Adelie    Adelie
         11    Adelie    Adelie
---                            
        327 Chinstrap Chinstrap
        328 Chinstrap Chinstrap
        341 Chinstrap    Adelie</code></pre>
</div>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">prediction</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.ce 
   0.05814 </code></pre>
</div>
</div>
<p>By default, the intermediate models produced at each resampling iteration are discarded after the prediction step to reduce memory consumption of the <code>ResampleResult</code> object (only the predictions are required to calculate most performance measures). However, it can sometimes be useful to inspect, compare, or extract information from these intermediate models. We can configure the <a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a> function to keep the fitted intermediate models by setting <code>store_models = TRUE</code>. Each model trained in a specific resampling iteration can then be accessed via <code>$learners[[i]]$model</code>, where <code>i</code> refers to the <code>i</code>-th resampling iteration:</p>
<div class="cell">
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">lrn_rpart</span>, <span class="va">cv3</span>, store_models <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co"># get the model from the first iteration</span></span>
<span><span class="va">rr</span><span class="op">$</span><span class="va">learners</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>n= 229 

node), split, n, loss, yval, (yprob)
      * denotes terminal node

1) root 229 129 Adelie (0.436681 0.192140 0.371179)  
  2) flipper_length&lt; 207.5 141  42 Adelie (0.702128 0.290780 0.007092)  
    4) bill_length&lt; 44.65 100   3 Adelie (0.970000 0.030000 0.000000) *
    5) bill_length&gt;=44.65 41   3 Chinstrap (0.048780 0.926829 0.024390) *
  3) flipper_length&gt;=207.5 88   4 Gentoo (0.011364 0.034091 0.954545) *</code></pre>
</div>
</div>
<p>In this example, we could then inspect the most important variables in each iteration to help us learn more about the respective fitted models:</p>
<div class="cell">
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># print 2nd and 3rd iteration</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">rr</span><span class="op">$</span><span class="va">learners</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span><span class="op">$</span><span class="va">model</span><span class="op">$</span><span class="va">variable.importance</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
flipper_length    bill_length     bill_depth      body_mass 
         87.23          81.27          66.26          59.46 
        island 
         51.22 

[[2]]
   bill_length flipper_length     bill_depth      body_mass 
         79.06          78.94          59.98          54.35 
        island 
         42.63 </code></pre>
</div>
</div>
</section><section id="sec-resamp-custom" class="level3" data-number="3.2.4"><h3 data-number="3.2.4" class="anchored" data-anchor-id="sec-resamp-custom">
<span class="header-section-number">3.2.4</span> Custom Resampling</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Sometimes it is necessary to perform resampling with custom splits, e.g., to reproduce results reported in a study with pre-defined folds.</p>
<p>A custom holdout resampling strategy can be constructed using <code>rsmp("custom")</code>, where the row IDs of the observations used for training and testing must be defined manually when instantiated with a task. In the example below, we first construct a custom holdout resampling strategy by manually assigning row IDs to the <code>$train</code> and <code>$test</code> fields, then construct a resampling strategy with two iterations by passing row IDs as list elements:</p>
<div class="cell">
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rsmp_custom</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"custom"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># resampling strategy with two iterations</span></span>
<span><span class="va">train_sets</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>, <span class="fl">153</span><span class="op">:</span><span class="fl">158</span>, <span class="fl">277</span><span class="op">:</span><span class="fl">280</span><span class="op">)</span></span>
<span><span class="va">rsmp_custom</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_penguins</span>,</span>
<span>  train <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">train_sets</span>, <span class="va">train_sets</span> <span class="op">+</span> <span class="fl">5</span><span class="op">)</span>,</span>
<span>  test <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">train_sets</span> <span class="op">+</span> <span class="fl">15</span>, <span class="va">train_sets</span> <span class="op">+</span> <span class="fl">25</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">resample</span><span class="op">(</span><span class="va">tsk_penguins</span>, <span class="va">lrn_rpart</span>, <span class="va">rsmp_custom</span><span class="op">)</span><span class="op">$</span><span class="fu">prediction</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;PredictionClassif&gt; for 30 observations:
    row_ids     truth response
         16    Adelie   Gentoo
         17    Adelie   Gentoo
         18    Adelie   Gentoo
---                           
        303 Chinstrap   Gentoo
        304 Chinstrap   Gentoo
        305 Chinstrap   Gentoo</code></pre>
</div>
</div>
<p>A custom cross-validation strategy can be more efficiently constructed with <code>rsmp("custom_cv")</code>. In this case, we now have to specify either a custom <code>factor</code> variable or a <code>factor</code> column from the data to determine the folds. In the example below, we use a smaller version of <code>tsk("penguins")</code> and instantiate a custom two-fold CV strategy using a <code>factor</code> variable called <code>folds</code> where the first and third rows are used as the test set in Fold 1, and the second and fourth rows are used as the test set in Fold 2:</p>
<div class="cell">
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_small</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span><span class="op">$</span><span class="fu">filter</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">100</span>, <span class="fl">200</span>, <span class="fl">300</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">rsmp_customcv</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"custom_cv"</span><span class="op">)</span></span>
<span><span class="va">folds</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html">as.factor</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">rsmp_customcv</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_small</span>, f <span class="op">=</span> <span class="va">folds</span><span class="op">)</span></span>
<span><span class="fu">resample</span><span class="op">(</span><span class="va">tsk_small</span>, <span class="va">lrn_rpart</span>, <span class="va">rsmp_customcv</span><span class="op">)</span><span class="op">$</span><span class="fu">predictions</span><span class="op">(</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
&lt;PredictionClassif&gt; for 2 observations:
 row_ids  truth response
       1 Adelie   Adelie
     200 Gentoo   Adelie

[[2]]
&lt;PredictionClassif&gt; for 2 observations:
 row_ids     truth response
     100    Adelie   Adelie
     300 Chinstrap   Adelie</code></pre>
</div>
</div>
</section><section id="sec-strat-group" class="level3" data-number="3.2.5"><h3 data-number="3.2.5" class="anchored" data-anchor-id="sec-strat-group">
<span class="header-section-number">3.2.5</span> Stratification and Grouping</h3>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
This section covers advanced ML or technical details.
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<p>Using column roles (<a href="../chapter2/data_and_basic_modeling.html#sec-row-col-roles" class="quarto-xref"><span>Section 2.6</span></a>), it is possible to group or stratify observations according to a particular column in the data. We will look at each of these in turn.</p>
<section id="grouped-resampling" class="level4 unlisted unnumbered"><h4 class="unlisted unnumbered anchored" data-anchor-id="grouped-resampling">Grouped Resampling</h4>
<p>Keeping observations together when the data is split can be useful, and sometimes essential, during resampling – spatial analysis (<a href="../chapter13/beyond_regression_and_classification.html#sec-spatiotemporal" class="quarto-xref"><span>Section 13.5</span></a>) is a prominent example, as observations belong to natural groups (e.g., countries). When observations belong to groups, we need to ensure all observations of the same group belong to <em>either</em> the training set <em>or</em> the test set to prevent potential leakage of information between training and testing. For example, in a longitudinal study, measurements are taken from the same individual at multiple time points. If we do not group these, we might overestimate the model’s generalization capability to unseen individuals, because observations of the same individuals might simultaneously be in the train and test set. In this context, the leave-one-out cross-validation strategy can be coarsened to the “leave-one-object-out” cross-validation strategy, where all observations associated with a certain group are left out (<a href="#fig-group" class="quarto-xref">Figure&nbsp;<span>3.6</span></a>).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-group" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Three images, each shows a green box with text 'Train' and white space around it with text 'Test'. Left (Iteration 1): green box with blue and red dots inside it and yellow dots outside it. Middle (Iteration 2): green box with blue and yellow dots inside it and red dots outside it. Right (Iteration 3): green box with yellow and red dots inside it and blue dots outside it.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-group-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-7.svg" class="img-fluid figure-img" style="width:100.0%" alt="Three images, each shows a green box with text 'Train' and white space around it with text 'Test'. Left (Iteration 1): green box with blue and red dots inside it and yellow dots outside it. Middle (Iteration 2): green box with blue and yellow dots inside it and red dots outside it. Right (Iteration 3): green box with yellow and red dots inside it and blue dots outside it.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-group-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.6: Illustration of the train-test splits of a leave-one-object-out cross-validation with 3 groups of observations (highlighted by different colors).
</figcaption></figure>
</div>
</div>
</div>
<p>The <code>"group"</code> column role allows us to specify the column in the data that defines the group structure of the observations. In the following code, we construct a leave-one-out resampling strategy, assign the <code>"group"</code> role to the ‘year’ column of <code>tsk("penguins")</code>, instantiate the resampling strategy, and finally show how the years are nicely separated in the first fold.</p>
<div class="cell">
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rsmp_loo</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"loo"</span><span class="op">)</span></span>
<span><span class="va">tsk_grp</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="va">tsk_grp</span><span class="op">$</span><span class="fu">set_col_roles</span><span class="op">(</span><span class="st">"year"</span>, <span class="st">"group"</span><span class="op">)</span></span>
<span><span class="va">rsmp_loo</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_grp</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_grp</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_loo</span><span class="op">$</span><span class="fu">train_set</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, cols <span class="op">=</span> <span class="st">"year"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>year
2008 2009 
 114  120 </code></pre>
</div>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_grp</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_loo</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>, cols <span class="op">=</span> <span class="st">"year"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>year
2007 
 110 </code></pre>
</div>
</div>
<p>Other cross-validation techniques work in a similar way, where folds are determined at a group level (as opposed to an observation level).</p>
</section><section id="stratified-sampling" class="level4 unlisted unnumbered"><h4 class="unlisted unnumbered anchored" data-anchor-id="stratified-sampling">Stratified Sampling</h4>
<p>Stratified sampling ensures that one or more discrete features within the training and test sets will have a similar distribution as in the original task containing all observations. This is especially useful when a discrete feature is highly imbalanced and we want to make sure that the distribution of that feature is similar in each resampling iteration (<a href="#fig-stratification" class="quarto-xref">Figure&nbsp;<span>3.7</span></a>). We can also stratify on the target feature to ensure that each intermediate model is fit on training data where the class distribution of the target is representative of the actual task, this is useful to ensure target classes are not strongly under-represented by random chance in individual resampling iterations, which would lead to degenerate estimations of the generalization performance.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-stratification" class="quarto-figure quarto-figure-center quarto-float anchored" alt="The figure shows rectangles in yellow and green to represent the majority and minority class respectively. On the left side are rectangles corresponding to the task before it is split; the majority class (yellow) on the left is clearly larger than the minority class (green) on the right. This is labeled 'Imabalanced Class Distribution'. In the next three boxes, labeled 'Iteration 1-3' respectively, the size difference between the majority and minority classes is preserved, i.e., the difference in size between majority and minority classes are equal.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-stratification-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/mlr3book_figures-8.svg" class="img-fluid figure-img" style="width:100.0%" alt="The figure shows rectangles in yellow and green to represent the majority and minority class respectively. On the left side are rectangles corresponding to the task before it is split; the majority class (yellow) on the left is clearly larger than the minority class (green) on the right. This is labeled 'Imabalanced Class Distribution'. In the next three boxes, labeled 'Iteration 1-3' respectively, the size difference between the majority and minority classes is preserved, i.e., the difference in size between majority and minority classes are equal.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-stratification-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.7: Illustration of a three-fold cross-validation with stratification for an imbalanced binary classification task with a majority class that is about twice as large as the minority class. In each resampling iteration, the class distribution from the available data is preserved (which is not necessarily the case for cross-validation without stratification).
</figcaption></figure>
</div>
</div>
</div>
<p>Unlike grouping, it is possible to stratify by multiple discrete features using the <code>"stratum"</code> column role (<a href="../chapter2/data_and_basic_modeling.html#sec-row-col-roles" class="quarto-xref"><span>Section 2.6</span></a>). In this case, strata would be formed out of each combination of the stratified features, e.g., for two stratified features A and B with levels Aa, Ab; Ba, Bb respectively then the created stratum would have the levels AaBa, AaBb, AbBa, AbBb.</p>
<p><code>tsk("penguins")</code> displays imbalance in the <code>species</code> column, as can be seen in the output below:</p>
<div class="cell">
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>cols <span class="op">=</span> <span class="st">"species"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>species
   Adelie Chinstrap    Gentoo 
   0.4419    0.1977    0.3605 </code></pre>
</div>
</div>
<p>Without specifying a <code>"stratum"</code> column role, the <code>species</code> column may have quite different class distributions across the CV folds, as can be seen in the example below.</p>
<div class="cell">
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rsmp_cv10</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fold1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>  cols <span class="op">=</span> <span class="st">"species"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">fold2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>  cols <span class="op">=</span> <span class="st">"species"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="st">"Fold 1"</span> <span class="op">=</span> <span class="va">fold1</span>, <span class="st">"Fold 2"</span> <span class="op">=</span> <span class="va">fold2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       Adelie Chinstrap Gentoo
Fold 1 0.4286    0.1143 0.4571
Fold 2 0.4286    0.2286 0.3429</code></pre>
</div>
</div>
<p>We can see across folds how Chinstrap is represented quite differently (0.11 vs.&nbsp;0.23)</p>
<p>When imbalance is severe, minority classes might not occur in the training sets entirely. Consequently, the intermediate models within these resampling iterations will never predict the missing class, resulting in a misleading performance estimate for any resampling strategy without stratification. The code below uses <code>species</code> as <code>"stratum"</code> column role to illustrate that the distribution of <code>species</code> in each test set will closely match the original distribution:</p>
<div class="cell">
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_str</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"penguins"</span><span class="op">)</span></span>
<span><span class="co"># set species to have both the 'target' and 'stratum' column role</span></span>
<span><span class="va">tsk_str</span><span class="op">$</span><span class="fu">set_col_roles</span><span class="op">(</span><span class="st">"species"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"target"</span>, <span class="st">"stratum"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">instantiate</span><span class="op">(</span><span class="va">tsk_str</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fold1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_str</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>  cols <span class="op">=</span> <span class="st">"species"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">fold2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/proportions.html">prop.table</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_str</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>rows <span class="op">=</span> <span class="va">rsmp_cv10</span><span class="op">$</span><span class="fu">test_set</span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>,</span>
<span>  cols <span class="op">=</span> <span class="st">"species"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="st">"Fold 1"</span> <span class="op">=</span> <span class="va">fold1</span>, <span class="st">"Fold 2"</span> <span class="op">=</span> <span class="va">fold2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       Adelie Chinstrap Gentoo
Fold 1 0.4444    0.1944 0.3611
Fold 2 0.4444    0.1944 0.3611</code></pre>
</div>
</div>
<p>You can view the observations that fall into each stratum using the <code>$strata</code> field of a <code>Task</code> object, this can be particularly useful when we are interested in multiple strata:</p>
<div class="cell">
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_str</span><span class="op">$</span><span class="fu">set_col_roles</span><span class="op">(</span><span class="st">"year"</span>, <span class="st">"stratum"</span><span class="op">)</span></span>
<span><span class="va">tsk_str</span><span class="op">$</span><span class="va">strata</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    N                      row_id
1: 50             1,2,3,4,5,6,...
2: 50       51,52,53,54,55,56,...
3: 52 101,102,103,104,105,106,...
4: 34 153,154,155,156,157,158,...
5: 46 187,188,189,190,191,192,...
6: 44 233,234,235,236,237,238,...
7: 26 277,278,279,280,281,282,...
8: 18 303,304,305,306,307,308,...
9: 24 321,322,323,324,325,326,...</code></pre>
</div>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># N above matches with numbers in table below</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">tsk_penguins</span><span class="op">$</span><span class="fu">data</span><span class="op">(</span>cols <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"species"</span>, <span class="st">"year"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>           year
species     2007 2008 2009
  Adelie      50   50   52
  Chinstrap   26   18   24
  Gentoo      34   46   44</code></pre>
</div>
</div>
</section></section></section><section id="sec-benchmarking" class="level2" data-number="3.3"><h2 data-number="3.3" class="anchored" data-anchor-id="sec-benchmarking">
<span class="header-section-number">3.3</span> Benchmarking</h2>
<p>Benchmarking in supervised machine learning refers to the comparison of different learners on one or more tasks. When comparing <em>multiple learners on a single task</em> or on a domain consisting of multiple similar tasks, the main aim is often to rank the learners according to a pre-defined performance measure and to identify the best-performing learner for the considered task or domain. When comparing <em>multiple learners on multiple tasks</em>, the main aim is often more of a scientific nature, e.g., to gain insights into how different learners perform in different data situations or whether there are certain data properties that heavily affect the performance of certain learners (or certain hyperparameters of learners). It is common (and good) practice for algorithm designers to analyze the generalization performance or runtime of a newly proposed learning algorithm in comparison to existing learners in a benchmark experiment. Since benchmarks usually consist of many evaluations that can be run independently of each other, <code>mlr3</code> offers the possibility of parallelizing them automatically, which we demonstrate in <a href="../chapter10/advanced_technical_aspects_of_mlr3.html#sec-parallel-resample" class="quarto-xref"><span>Section 10.1.2</span></a>. In this section, we will focus on the basic setup of benchmark experiments that will be applicable in the majority of use cases, in <a href="../chapter11/large-scale_benchmarking.html" class="quarto-xref"><span>Chapter 11</span></a> we will look at more complex, large-scale, benchmark experiments.</p>
<section id="sec-bm-design" class="level3" data-number="3.3.1"><h3 data-number="3.3.1" class="anchored" data-anchor-id="sec-bm-design">
<span class="header-section-number">3.3.1</span> benchmark()</h3>
<p>Benchmark experiments in <code>mlr3</code> are conducted with <a href="https://mlr3.mlr-org.com/reference/benchmark.html"><code>benchmark()</code></a>, which simply runs <a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a> on each task and learner separately, then collects the results. The provided resampling strategy is automatically instantiated on each task to ensure that all learners are compared against the same training and test data.</p>
<p>To use the <code>benchmark()</code> function we first call <a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html"><code>benchmark_grid()</code></a>, which constructs an exhaustive <em>design</em> to describe all combinations of the learners, tasks and resamplings to be used in a benchmark experiment, and instantiates the resampling strategies. By example, below we set up a design to see if a random forest, decision tree, or featureless baseline (<a href="../chapter2/data_and_basic_modeling.html#sec-basics-featureless" class="quarto-xref"><span>Section 2.2.4</span></a>), performs best across two classification tasks.</p>
<div class="cell">
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tasks</span> <span class="op">=</span> <span class="fu">tsks</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"german_credit"</span>, <span class="st">"sonar"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">learners</span> <span class="op">=</span> <span class="fu">lrns</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.rpart"</span>, <span class="st">"classif.ranger"</span>,</span>
<span>  <span class="st">"classif.featureless"</span><span class="op">)</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span><span class="va">rsmp_cv5</span> <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">design</span> <span class="op">=</span> <span class="fu">benchmark_grid</span><span class="op">(</span><span class="va">tasks</span>, <span class="va">learners</span>, <span class="va">rsmp_cv5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">design</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            task             learner resampling
1: german_credit       classif.rpart         cv
2: german_credit      classif.ranger         cv
3: german_credit classif.featureless         cv
4:         sonar       classif.rpart         cv
5:         sonar      classif.ranger         cv
6:         sonar classif.featureless         cv</code></pre>
</div>
</div>
<p>The resulting design is essentially just a <code>data.table</code>, which can be modified if you want to remove particular combinations or could even be created from scratch without the <code>benchmark_grid()</code> function. Note that this <code>data.table</code> has list columns that contain R6 objects of tasks, learners, and resampling instances.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Reproducibility When Using <code>benchmark_grid()</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>By default, <a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html"><code>benchmark_grid()</code></a> instantiates the resamplings on the tasks, which means that concrete train-test splits are generated. Since this process is stochastic, it is necessary to set a seed <strong>before</strong> calling <code>benchmark_grid()</code> to ensure reproducibility of the data splits.</p>
</div>
</div>
<p>The constructed benchmark design can then be passed to <code>benchmark()</code> to run the experiment and the result is a <a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html"><code>BenchmarkResult</code></a> object:</p>
<div class="cell">
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">bmr</span> <span class="op">=</span> <span class="fu">benchmark</span><span class="op">(</span><span class="va">design</span><span class="op">)</span></span>
<span><span class="va">bmr</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;BenchmarkResult&gt; of 30 rows with 6 resampling runs
 nr       task_id          learner_id resampling_id iters warnings
  1 german_credit       classif.rpart            cv     5        0
  2 german_credit      classif.ranger            cv     5        0
  3 german_credit classif.featureless            cv     5        0
  4         sonar       classif.rpart            cv     5        0
  5         sonar      classif.ranger            cv     5        0
  6         sonar classif.featureless            cv     5        0
1 variable not shown: [errors]</code></pre>
</div>
</div>
<p>As <code>benchmark()</code> is just an extension of <code>resample()</code>, we can once again use <code>$score()</code>, or <code>$aggregate()</code> depending on your use-case, though note that in this case <code>$score()</code> will return results over each fold of each learner/task/resampling combination.</p>
<div class="cell">
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">bmr</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span>, <span class="fl">13</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span><span class="va">iteration</span>, <span class="va">task_id</span>, <span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   iteration       task_id          learner_id classif.ce
1:         1 german_credit       classif.rpart      0.280
2:         2 german_credit      classif.ranger      0.235
3:         3 german_credit classif.featureless      0.275</code></pre>
</div>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">bmr</span><span class="op">$</span><span class="fu">aggregate</span><span class="op">(</span><span class="op">)</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span><span class="va">task_id</span>, <span class="va">learner_id</span>, <span class="va">classif.ce</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         task_id          learner_id classif.ce
1: german_credit       classif.rpart     0.2760
2: german_credit      classif.ranger     0.2550
3: german_credit classif.featureless     0.3000
4:         sonar       classif.rpart     0.2840
5:         sonar      classif.ranger     0.1822
6:         sonar classif.featureless     0.4661</code></pre>
</div>
</div>
<p>This would conclude a basic benchmark experiment where you can draw tentative conclusions about model performance, in this case we would possibly conclude that the random forest is the best of all three models on each task. We draw conclusions cautiously here as we have not run any statistical tests or included standard errors of measures, so we cannot definitively say if one model outperforms the other.</p>
<p>As the results of <code>$score()</code> and <code>$aggregate()</code> are returned in a <code>data.table</code>, you can post-process and analyze the results in any way you want. A common <em>mistake</em> is to average the learner performance across all tasks when the tasks vary significantly. This is a mistake as averaging the performance will miss out important insights into how learners compare on ‘easier’ or more ‘difficult’ predictive problems. A more robust alternative to compare the overall algorithm performance across multiple tasks is to compute the ranks of each learner on each task separately and then calculate the average ranks. This can provide a better comparison as task-specific ‘quirks’ are taken into account by comparing learners within tasks before comparing them across tasks. However, using ranks will lose information about the numerical differences between the calculated performance scores. Analysis of benchmark experiments, including statistical tests, is covered in more detail in <a href="../chapter11/large-scale_benchmarking.html#sec-benchmark-analysis" class="quarto-xref"><span>Section 11.3</span></a>.</p>
</section><section id="sec-bm-resamp" class="level3" data-number="3.3.2"><h3 data-number="3.3.2" class="anchored" data-anchor-id="sec-bm-resamp">
<span class="header-section-number">3.3.2</span> BenchmarkResult Objects</h3>
<p>A <a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html"><code>BenchmarkResult</code></a> object is a collection of multiple <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a> objects.</p>
<div class="cell">
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">bmrdt</span> <span class="op">=</span> <span class="fu">as.data.table</span><span class="op">(</span><span class="va">bmr</span><span class="op">)</span></span>
<span><span class="va">bmrdt</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fu">.</span><span class="op">(</span><span class="va">task</span>, <span class="va">learner</span>, <span class="va">resampling</span>, <span class="va">iteration</span><span class="op">)</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                task                   learner         resampling
1: &lt;TaskClassif[51]&gt; &lt;LearnerClassifRpart[38]&gt; &lt;ResamplingCV[20]&gt;
2: &lt;TaskClassif[51]&gt; &lt;LearnerClassifRpart[38]&gt; &lt;ResamplingCV[20]&gt;
1 variable not shown: [iteration]</code></pre>
</div>
</div>
<p>The contents of a <code>BenchmarkResult</code> and <code>ResampleResult</code> (<a href="#sec-resampling-inspect" class="quarto-xref"><span>Section 3.2.3</span></a>) are almost identical and the stored <code>ResampleResult</code>s can be extracted via the <code>$resample_result(i)</code> method, where <code>i</code> is the index of the performed resample experiment. This allows us to investigate the extracted <code>ResampleResult</code> and individual resampling iterations as shown in <a href="#sec-resampling" class="quarto-xref"><span>Section 3.2</span></a>, as well as the predictions from each fold with <code>$resample_result(i)$predictions()</code>.</p>
<div class="cell">
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr1</span> <span class="op">=</span> <span class="va">bmr</span><span class="op">$</span><span class="fu">resample_result</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">rr1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;ResampleResult&gt; with 5 resampling iterations
       task_id    learner_id resampling_id iteration warnings errors
 german_credit classif.rpart            cv         1        0      0
 german_credit classif.rpart            cv         2        0      0
 german_credit classif.rpart            cv         3        0      0
 german_credit classif.rpart            cv         4        0      0
 german_credit classif.rpart            cv         5        0      0</code></pre>
</div>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr2</span> <span class="op">=</span> <span class="va">bmr</span><span class="op">$</span><span class="fu">resample_result</span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In addition, <a href="https://mlr3.mlr-org.com/reference/as_benchmark_result.html"><code>as_benchmark_result()</code></a> can be used to convert objects from <code>ResampleResult</code> to <code>BenchmarkResult</code>. The <code><a href="https://rdrr.io/r/base/c.html">c()</a></code>-method can be used to combine multiple <code>BenchmarkResult</code> objects, which can be useful when conducting experiments across multiple machines:</p>
<div class="cell">
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">bmr1</span> <span class="op">=</span> <span class="fu">as_benchmark_result</span><span class="op">(</span><span class="va">rr1</span><span class="op">)</span></span>
<span><span class="va">bmr2</span> <span class="op">=</span> <span class="fu">as_benchmark_result</span><span class="op">(</span><span class="va">rr2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">bmr1</span>, <span class="va">bmr2</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;BenchmarkResult&gt; of 10 rows with 2 resampling runs
 nr       task_id     learner_id resampling_id iters warnings errors
  1 german_credit  classif.rpart            cv     5        0      0
  2 german_credit classif.ranger            cv     5        0      0</code></pre>
</div>
</div>
<p>Boxplots are most commonly used to visualize benchmark experiments as they can intuitively summarize results across tasks and learners simultaneously.</p>
<div class="cell">
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">bmr</span>, measure <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-benchmark-box" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Nine boxplots, one corresponding to each task/learner combination. In all cases the random forest performs best and the featureless baseline the worst.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-benchmark-box-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-benchmark-box-1.png" class="img-fluid figure-img" style="width:70.0%" alt="Nine boxplots, one corresponding to each task/learner combination. In all cases the random forest performs best and the featureless baseline the worst.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-benchmark-box-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.8: Boxplots of accuracy scores for each learner across resampling iterations and the three tasks. Random forests (<code>lrn("classif.ranger")</code>) consistently outperforms the other learners.
</figcaption></figure>
</div>
</div>
</div>
</section></section><section id="sec-roc" class="level2 page-columns page-full" data-number="3.4"><h2 data-number="3.4" class="anchored" data-anchor-id="sec-roc">
<span class="header-section-number">3.4</span> Evaluation of Binary Classifiers</h2>
<p>In <a href="../chapter2/data_and_basic_modeling.html#sec-basics-classif-learner" class="quarto-xref"><span>Section 2.5.3</span></a> we touched on the concept of a confusion matrix and how it can be used to break down classification errors in more detail. In this section, we will look at specialized performance measures for binary classification in more detail. We will first return to the confusion matrix and discuss measures that can be derived from it and then will look at ROC analysis which builds on these measures. See Chapters 7 and 8 of <span class="citation" data-cites="provost2013">Provost and Fawcett (<a href="../references.html#ref-provost2013" role="doc-biblioref">2013</a>)</span> for a more detailed introduction to ROC measures.</p>
<section id="confusion-matrix" class="level3" data-number="3.4.1"><h3 data-number="3.4.1" class="anchored" data-anchor-id="confusion-matrix">
<span class="header-section-number">3.4.1</span> Confusion Matrix</h3>
<p>To recap, a confusion matrix summarizes the following quantities in a two-dimensional contingency table (see also <a href="#fig-confusion" class="quarto-xref">Figure&nbsp;<span>3.9</span></a>):</p>
<ul>
<li>True positives (TPs): Positive instances that are correctly classified as positive.</li>
<li>True negatives (TNs): Negative instances that are correctly classified as negative.</li>
<li>False positives (FPs): Negative instances that are incorrectly classified as positive.</li>
<li>False negatives (FNs): Positive instances that are incorrectly classified as negative.</li>
</ul>
<p>Different applications may have a particular interest in one (or multiple) of the aforementioned quantities. For example, the <code>tsk("spam")</code> classification task is concerned with classifying if mail is spam (positive class) or not (negative class). In this case, we are likely to accept FNs (some spam classified as genuine mail) as long as we have a low number of FPs (genuine and possibly important mail classified as spam). In another example, say we are predicting if a travel bag contains a weapon (positive class) or not (negative class) at an airport. This classifier must have a very high number of TPs (as FNs are not acceptable at all), even if this comes at the expense of more FPs (false alarms).</p>
<p>As we saw in <a href="../chapter2/data_and_basic_modeling.html#sec-basics-classif-learner" class="quarto-xref"><span>Section 2.5.3</span></a>, it is possible for a classifier to have a good classification accuracy but to overlook the nuances provided by a full confusion matrix, as in the following <code>tsk("german_credit")</code> example:</p>
<div class="cell">
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">tsk_german</span> <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"german_credit"</span><span class="op">)</span></span>
<span><span class="va">lrn_ranger</span> <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span></span>
<span><span class="va">splits</span> <span class="op">=</span> <span class="fu">partition</span><span class="op">(</span><span class="va">tsk_german</span>, ratio <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lrn_ranger</span><span class="op">$</span><span class="fu">train</span><span class="op">(</span><span class="va">tsk_german</span>, <span class="va">splits</span><span class="op">$</span><span class="va">train</span><span class="op">)</span></span>
<span><span class="va">prediction</span> <span class="op">=</span> <span class="va">lrn_ranger</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span><span class="va">tsk_german</span>, <span class="va">splits</span><span class="op">$</span><span class="va">test</span><span class="op">)</span></span>
<span><span class="va">prediction</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.acc 
      0.725 </code></pre>
</div>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">prediction</span><span class="op">$</span><span class="va">confusion</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        truth
response good bad
    good  123  38
    bad    17  22</code></pre>
</div>
</div>
<p>The classification accuracy only takes into account the TPs and TNs, whereas the confusion matrix provides a more holistic picture of the classifier’s performance.</p>
<p>On their own, the absolute numbers in a confusion matrix can be less useful when there is class imbalance. Instead, several normalized measures can be derived (<a href="#fig-confusion" class="quarto-xref">Figure&nbsp;<span>3.9</span></a>):</p>
<ul>
<li>
<strong>True Positive Rate (TPR)</strong>, <strong>Sensitivity</strong> or <strong>Recall</strong>: How many of the true positives did we predict as positive?</li>
<li>
<strong>True Negative Rate (TNR)</strong> or <strong>Specificity</strong>: How many of the true negatives did we predict as negative?</li>
<li>
<strong>False Positive Rate (FPR)</strong>, or <span class="math inline">\(1 -\)</span> <strong>Specificity</strong>: How many of the true negatives did we predict as positive?</li>
<li>
<strong>Positive Predictive Value (PPV)</strong> or <strong>Precision</strong>: If we predict positive how likely is it a true positive?</li>
<li>
<strong>Negative Predictive Value (NPV)</strong>: If we predict negative how likely is it a true negative?</li>
<li>
<strong>Accuracy (ACC)</strong>: The proportion of correctly classified instances out of the total number of instances.</li>
<li>
<strong>F1-score</strong>: The harmonic mean of precision and recall, which balances the trade-off between precision and recall. It is calculated as <span class="math inline">\(2 \times \frac{Precision \times Recall}{Precision + Recall}\)</span>.</li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div id="fig-confusion" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Representation of a confusion matrix with entries 'TP' when both 'True class y' is '+'' and 'Predicted Class yhat' is '+', 'TN' when both are '-', 'FP' when True is '-' and Predicted is '+' and finally 'FN' when True is '+' but Predicted is '-'. In the margins is 'PPV = TP/(TP+FP)', 'NPV = TN/(FN+TN)', 'ACC=(TP+TN)/(TP+FP+FN+TN)', 'TNR=TN/(FP+TN)', 'TPR=TP/(TP+FN)'.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="Figures/confusion_matrix.svg" class="img-fluid figure-img" style="width:100.0%" alt="Representation of a confusion matrix with entries 'TP' when both 'True class y' is '+'' and 'Predicted Class yhat' is '+', 'TN' when both are '-', 'FP' when True is '-' and Predicted is '+' and finally 'FN' when True is '+' but Predicted is '-'. In the margins is 'PPV = TP/(TP+FP)', 'NPV = TN/(FN+TN)', 'ACC=(TP+TN)/(TP+FP+FN+TN)', 'TNR=TN/(FP+TN)', 'TPR=TP/(TP+FN)'.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.9: Binary confusion matrix of ground truth class vs.&nbsp;predicted class.
</figcaption></figure>
</div>
</div>
</div>
<p>The <a href="https://cran.r-project.org/package=mlr3measures"><code>mlr3measures</code></a> package allows you to compute several common confusion matrix-based measures using the <a href="https://www.rdocumentation.org/packages/mlr3measures/topics/confusion_matrix"><code>confusion_matrix()</code></a> function:</p>
<div class="cell">
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">mlr3measures</span><span class="fu">::</span><span class="fu"><a href="https://mlr3measures.mlr-org.com/reference/confusion_matrix.html">confusion_matrix</a></span><span class="op">(</span>truth <span class="op">=</span> <span class="va">prediction</span><span class="op">$</span><span class="va">truth</span>,</span>
<span>  response <span class="op">=</span> <span class="va">prediction</span><span class="op">$</span><span class="va">response</span>, positive <span class="op">=</span> <span class="va">tsk_german</span><span class="op">$</span><span class="va">positive</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        truth
response good bad
    good  123  38
    bad    17  22
acc :  0.7250; ce  :  0.2750; dor :  4.1889; f1  :  0.8173 
fdr :  0.2360; fnr :  0.1214; fomr:  0.4359; fpr :  0.6333 
mcc :  0.2836; npv :  0.5641; ppv :  0.7640; tnr :  0.3667 
tpr :  0.8786 </code></pre>
</div>
</div>
<p>We now have a better idea of the random forest predictions on <code>tsk("german_credit")</code>, in particular, the false positive rate is quite high. It is generally difficult to achieve a high TPR and low FPR simultaneously because there is often a trade-off between the two rates. When a binary classifier predicts probabilities instead of discrete classes (<code>predict_type = "prob"</code>), we could set a threshold to cut off the probabilities to change how we assign observations to the positive/negative class (see <a href="../chapter2/data_and_basic_modeling.html#sec-classif-prediction" class="quarto-xref"><span>Section 2.5.4</span></a>). Increasing the threshold for identifying the positive cases, leads to a higher number of negative predictions, fewer positive predictions, and therefore a lower (and better) FPR but a lower (and worse) TPR – the reverse holds if we lower the threshold. Instead of arbitrarily changing a threshold to ‘game’ these two numbers, a more robust way to tradeoff between TPR and FPR is to use ROC analysis, discussed next.</p>
</section><section id="sec-roc-space" class="level3 page-columns page-full" data-number="3.4.2"><h3 data-number="3.4.2" class="anchored" data-anchor-id="sec-roc-space">
<span class="header-section-number">3.4.2</span> ROC Analysis</h3>
<p>ROC (Receiver Operating Characteristic) analysis is widely used to evaluate binary classifiers by visualizing the trade-off between the TPR and the FPR.</p>
<p>The ROC curve is a line graph with TPR on the y-axis and the FPR on the x-axis. To understand the usefulness of this curve, first consider the simple case of a hard labeling classifier (<code>predict_type = "response"</code>) that classifies observations as either positive or negative. This classifier would be represented as a single point in the ROC space (see <a href="#fig-roc" class="quarto-xref">Figure&nbsp;<span>3.10</span></a>, panel (a)). The best classifier would lie on the top-left corner where the TPR is <span class="math inline">\(1\)</span> and the FPR is <span class="math inline">\(0\)</span>. Classifiers on the diagonal predict class labels randomly (with different class proportions). For example, if each positive instance will be randomly classified (ignoring features) with 25% as the positive class, we would obtain a TPR of 0.25. If we assign each negative instance randomly to the positive class, we would have an FPR of 0.25. In practice, we should never obtain a classifier below the diagonal and a point in the ROC space below the diagonal might indicate that the positive and negative class labels have been switched by the classifier.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-roc" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two plots labeled (a) and (b). Both have 'FPR' between 0-1 on x-axis and 'TPR' between 0-1 on y-axis, both also have a diagonal line y=x with text 'baseline (random classifiers)'. (a): There is a green dot in upper left corner at (0,1). There is a triangle labeled C1 at around (0.1,0.75), a square labeled C2 at around (0.24, 0.75), and a plus labeled C3 at around (0.25, 0.8). (b) is same as (a) except now there are three dashed lines such that each of the points from (a) lies on one of these lines. The lines roughly curve from (0,0) towards (0,1) and then to (1,1)">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-roc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-roc-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Two plots labeled (a) and (b). Both have 'FPR' between 0-1 on x-axis and 'TPR' between 0-1 on y-axis, both also have a diagonal line y=x with text 'baseline (random classifiers)'. (a): There is a green dot in upper left corner at (0,1). There is a triangle labeled C1 at around (0.1,0.75), a square labeled C2 at around (0.24, 0.75), and a plus labeled C3 at around (0.25, 0.8). (b) is same as (a) except now there are three dashed lines such that each of the points from (a) lies on one of these lines. The lines roughly curve from (0,0) towards (0,1) and then to (1,1)">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-roc-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.10: Panel (a): ROC space with best discrete classifier, two baseline classifiers – one that always predicts the positive class and one that never predicts the positive class – and three ‘real’ classifiers C1, C2, C3. We cannot say if C1 or C3 is better than the other as both are better in one metric. C2 is clearly worse than C1 and C3, which are better in at least one metric than C2 while not being worse in any other metric. Panel (b): ROC curves of the best classifier (AUC = 1), of a random guessing classifier (AUC = 0.5), and the classifiers C1, C3, and C2.
</figcaption></figure>
</div>
</div>
</div>
<p>Now consider classifiers that predict probabilities instead of discrete classes. Using different thresholds to cut off predicted probabilities and assign them to the positive and negative class will lead to different TPRs and FPRs and by plotting these values across different thresholds we can characterize the behavior of a binary classifier – this is the ROC curve. For example, we can use the previous <a href="https://mlr3.mlr-org.com/reference/Prediction.html"><code>Prediction</code></a> object to compute all possible TPR and FPR combinations by thresholding the predicted probabilities across all possible thresholds, which is exactly what <code><a href="https://mlr3viz.mlr-org.com/reference/autoplot.PredictionClassif.html">mlr3viz::autoplot.PredictionClassif</a></code> will do when <code>type = "roc"</code> is selected:</p>
<div class="cell">
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">prediction</span>, type <span class="op">=</span> <span class="st">"roc"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-basics-roc-ranger" class="quarto-figure quarto-figure-center quarto-float anchored" alt="ROC curve with &quot;1 - Specificity&quot; on x-axis (between 0-1) and &quot;Sensitivity&quot; on y-axis (between 0-1). There is a line from around (0,0) to (0.3,0.75) to (1, 1).">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-basics-roc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-roc-ranger-1.png" class="img-fluid figure-img" style="width:70.0%" alt="ROC curve with &quot;1 - Specificity&quot; on x-axis (between 0-1) and &quot;Sensitivity&quot; on y-axis (between 0-1). There is a line from around (0,0) to (0.3,0.75) to (1, 1).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basics-roc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.11: ROC-curve based on the <code>german_credit</code> dataset and the <code>classif.ranger</code> random forest learner. Recall FPR = <span class="math inline">\(1 -\)</span> Specificity and TPR = Sensitivity.
</figcaption></figure>
</div>
</div>
</div>
<div class="page-columns page-full"><p>A natural performance measure that can be derived from the ROC curve is the area under the curve (AUC), implemented in <code>msr("classif.auc")</code>. The AUC can be interpreted as the probability that a randomly chosen positive instance has a higher predicted probability of belonging to the positive class than a randomly chosen negative instance. Therefore, higher values (closer to <span class="math inline">\(1\)</span>) indicate better performance. Random classifiers (such as the featureless baseline) will always have an AUC of (approximately, when evaluated empirically) 0.5 (see <a href="#fig-roc" class="quarto-xref">Figure&nbsp;<span>3.10</span></a>, panel (b)).</p><div class="no-row-height column-margin column-container"><span class="margin-aside">area under the curve</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">prediction</span><span class="op">$</span><span class="fu">score</span><span class="op">(</span><span class="fu">msr</span><span class="op">(</span><span class="st">"classif.auc"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>classif.auc 
     0.7435 </code></pre>
</div>
</div>
<p>Evaluating our random forest on <code>tsk("german_credit")</code> results in an AUC of around 0.74, which is acceptable but could be better.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Multiclass ROC and AUC
</div>
</div>
<div class="callout-body-container callout-body">
<p>Extensions of ROC analysis for multiclass classifiers exist <span class="citation" data-cites="hand2001simple">(see e.g., <a href="../references.html#ref-hand2001simple" role="doc-biblioref">Hand and Till 2001</a>)</span> but we only cover the more common binary classification case in this book. Generalizations of the AUC measure to multiclass classification are implemented in <code>mlr3</code>, see <code>msr("classif.mauc_au1p")</code>.</p>
</div>
</div>
<div class="page-columns page-full"><p>We can also plot the precision-recall curve (PRC) which visualizes the PPV/precision vs.&nbsp;TPR/recall. The main difference between ROC curves and PR curves is that the number of true-negatives are ignored in the latter. This can be useful in imbalanced populations where the positive class is rare, and where a classifier with high TPR may still not be very informative and have low PPV. See <span class="citation" data-cites="davis2006relationship">Davis and Goadrich (<a href="../references.html#ref-davis2006relationship" role="doc-biblioref">2006</a>)</span> for a detailed discussion about the relationship between the PRC and ROC curves.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Precision-recall Curve</span></div></div>
<div class="cell">
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">prediction</span>, type <span class="op">=</span> <span class="st">"prc"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-basics-prc-ranger" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Line curve with &quot;Recall&quot; on x-axis (between 0-1) and &quot;Precision&quot; on y-axis (between 0-1). There is a horizontal line through around y=0.74. There is also a line decreasing from (0,1) to (1,0.74).">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-basics-prc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-prc-ranger-1.png" class="img-fluid figure-img" style="width:70.0%" alt="Line curve with &quot;Recall&quot; on x-axis (between 0-1) and &quot;Precision&quot; on y-axis (between 0-1). There is a horizontal line through around y=0.74. There is also a line decreasing from (0,1) to (1,0.74).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basics-prc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.12: Precision-Recall curve based on <code>tsk("german_credit")</code> and <code>lrn("classif.ranger")</code>.
</figcaption></figure>
</div>
</div>
</div>
<p>Another useful way to think about the performance of a classifier is to visualize the relationship of a performance metric over varying thresholds, for example, see <a href="#fig-basics-fpracc-ranger" class="quarto-xref">Figure&nbsp;<span>3.13</span></a> to inspect the FPR and accuracy across all possible thresholds:</p>
<div class="cell">
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">autoplot</span><span class="op">(</span><span class="va">prediction</span>, type <span class="op">=</span> <span class="st">"threshold"</span>, measure <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.fpr"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">prediction</span>, type <span class="op">=</span> <span class="st">"threshold"</span>, measure <span class="op">=</span> <span class="fu">msr</span><span class="op">(</span><span class="st">"classif.acc"</span><span class="op">)</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-basics-fpracc-ranger" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-basics-fpracc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-basics-fpracc-ranger" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-basics-fpracc-ranger-1" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two line graphs, both with &quot;Probability Threshold&quot; on x-axis from 0-1. Left: &quot;classif.fpr&quot; on y-axis. Line slowly decreases from (0,1) to (1,0). Right: &quot;classif.acc&quot; on y-axis. Line travels from (0,0.7) to (0.25,0.7) to (0.4,0.75) to (1, 0.3).">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-basics-fpracc-ranger-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-fpracc-ranger-1.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-basics-fpracc-ranger" alt="Two line graphs, both with &quot;Probability Threshold&quot; on x-axis from 0-1. Left: &quot;classif.fpr&quot; on y-axis. Line slowly decreases from (0,1) to (1,0). Right: &quot;classif.acc&quot; on y-axis. Line travels from (0,0.7) to (0.25,0.7) to (0.4,0.75) to (1, 0.3).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-basics-fpracc-ranger-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) FPR
</figcaption></figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-basics-fpracc-ranger" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-basics-fpracc-ranger-2" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two line graphs, both with &quot;Probability Threshold&quot; on x-axis from 0-1. Left: &quot;classif.fpr&quot; on y-axis. Line slowly decreases from (0,1) to (1,0). Right: &quot;classif.acc&quot; on y-axis. Line travels from (0,0.7) to (0.25,0.7) to (0.4,0.75) to (1, 0.3).">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-basics-fpracc-ranger-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-fpracc-ranger-2.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-basics-fpracc-ranger" alt="Two line graphs, both with &quot;Probability Threshold&quot; on x-axis from 0-1. Left: &quot;classif.fpr&quot; on y-axis. Line slowly decreases from (0,1) to (1,0). Right: &quot;classif.acc&quot; on y-axis. Line travels from (0,0.7) to (0.25,0.7) to (0.4,0.75) to (1, 0.3).">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-basics-fpracc-ranger-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Accuracy
</figcaption></figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basics-fpracc-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.13: Comparing threshold and FPR (left) with threshold and accuracy (right) for the random forest trained on <code>tsk("german_credit")</code>.
</figcaption></figure>
</div>
<p>This visualization would show us that changing the threshold from the default 0.5 to a higher value like 0.7 would greatly reduce the FPR while reducing accuracy by only a few percentage points. Depending on the problem at hand, this might be a perfectly desirable trade-off.</p>
<p>These visualizations are also available for <a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a> objects. In this case, the predictions of individual resampling iterations are merged before calculating a ROC or PR curve (micro averaged):</p>
<div class="cell">
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rr</span> <span class="op">=</span> <span class="fu">resample</span><span class="op">(</span></span>
<span>  task <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"german_credit"</span><span class="op">)</span>,</span>
<span>  learner <span class="op">=</span> <span class="fu">lrn</span><span class="op">(</span><span class="st">"classif.ranger"</span>, predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span>,</span>
<span>  resampling <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">rr</span>, type <span class="op">=</span> <span class="st">"roc"</span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">rr</span>, type <span class="op">=</span> <span class="st">"prc"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-basics-rocpr-ranger" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-basics-rocpr-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-basics-rocpr-ranger" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-basics-rocpr-ranger-1" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two line graphs. Left is ROC curve with the &quot;best&quot; point close to (0.25, 0.75). Right is PR curve ending at 0.74.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-basics-rocpr-ranger-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-rocpr-ranger-1.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-basics-rocpr-ranger" alt="Two line graphs. Left is ROC curve with the &quot;best&quot; point close to (0.25, 0.75). Right is PR curve ending at 0.74.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-basics-rocpr-ranger-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) ROC
</figcaption></figure>
</div>
</div>
<div class="cell-output-display quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-basics-rocpr-ranger" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-basics-rocpr-ranger-2" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two line graphs. Left is ROC curve with the &quot;best&quot; point close to (0.25, 0.75). Right is PR curve ending at 0.74.">
<figure class="quarto-float quarto-subfloat-fig figure"><div aria-describedby="fig-basics-rocpr-ranger-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-rocpr-ranger-2.png" class="img-fluid figure-img" style="width:100.0%" data-ref-parent="fig-basics-rocpr-ranger" alt="Two line graphs. Left is ROC curve with the &quot;best&quot; point close to (0.25, 0.75). Right is PR curve ending at 0.74.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-basics-rocpr-ranger-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) PR Curve
</figcaption></figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basics-rocpr-ranger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.14: Comparing ROC (left) and PR curve (right) for a random forest trained on <code>tsk("german_credit")</code>.
</figcaption></figure>
</div>
<p>Finally, we can visualize ROC/PR curves for a <a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html"><code>BenchmarkResult</code></a> to compare multiple learners on the same <a href="https://mlr3.mlr-org.com/reference/Task.html"><code>Task</code></a>:</p>
<div class="cell">
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://patchwork.data-imaginist.com">patchwork</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">design</span> <span class="op">=</span> <span class="fu">benchmark_grid</span><span class="op">(</span></span>
<span>  tasks <span class="op">=</span> <span class="fu">tsk</span><span class="op">(</span><span class="st">"german_credit"</span><span class="op">)</span>,</span>
<span>  learners <span class="op">=</span> <span class="fu">lrns</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"classif.rpart"</span>, <span class="st">"classif.ranger"</span><span class="op">)</span>,</span>
<span>    predict_type <span class="op">=</span> <span class="st">"prob"</span><span class="op">)</span>,</span>
<span>  resamplings <span class="op">=</span> <span class="fu">rsmp</span><span class="op">(</span><span class="st">"cv"</span>, folds <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="va">bmr</span> <span class="op">=</span> <span class="fu">benchmark</span><span class="op">(</span><span class="va">design</span><span class="op">)</span></span>
<span><span class="fu">autoplot</span><span class="op">(</span><span class="va">bmr</span>, type <span class="op">=</span> <span class="st">"roc"</span><span class="op">)</span> <span class="op">+</span> <span class="fu">autoplot</span><span class="op">(</span><span class="va">bmr</span>, type <span class="op">=</span> <span class="st">"prc"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu"><a href="https://patchwork.data-imaginist.com/reference/plot_layout.html">plot_layout</a></span><span class="op">(</span>guides <span class="op">=</span> <span class="st">"collect"</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-basics-rocpr-bmr" class="quarto-figure quarto-figure-center quarto-float anchored" alt="Two line graphs, each with two lines for decision tree and random forest. Left is ROC curve showing random forest has consistently better TPR/FPR trade-off. Right is PR Curve showing random forest has better Precision/Recall trade-off.">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-basics-rocpr-bmr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="evaluation_and_benchmarking_files/figure-html/fig-basics-rocpr-bmr-1.png" class="img-fluid figure-img" style="width:100.0%" alt="Two line graphs, each with two lines for decision tree and random forest. Left is ROC curve showing random forest has consistently better TPR/FPR trade-off. Right is PR Curve showing random forest has better Precision/Recall trade-off.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basics-rocpr-bmr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.15: Comparing random forest (green) and decision tree (purple) using ROC and PR Curves.
</figcaption></figure>
</div>
</div>
</div>
</section></section><section id="conclusion" class="level2" data-number="3.5"><h2 data-number="3.5" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">3.5</span> Conclusion</h2>
<p>In this chapter, we learned how to estimate the generalization performance of a model via resampling strategies, from holdout to cross-validation and bootstrap, and how to automate the comparison of multiple learners in benchmark experiments. We also covered the basics of performance measures for binary classification, including the confusion matrix, ROC analysis, and precision-recall curves. These topics are fundamental in supervised learning and will continue to be built upon throughout this book. In particular, <a href="../chapter4/hyperparameter_optimization.html" class="quarto-xref"><span>Chapter 4</span></a> utilizes evaluation in automated model tuning to improve performance, in <a href="../chapter11/large-scale_benchmarking.html" class="quarto-xref"><span>Chapter 11</span></a> we look at large benchmarks and their statistical analysis, and in <a href="../chapter13/beyond_regression_and_classification.html" class="quarto-xref"><span>Chapter 13</span></a> we will take a look at specialized tasks that require different resampling strategies.</p>
<div id="tbl-api-performance" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-api-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3.1: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable).
</figcaption><div aria-describedby="tbl-api-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead><tr class="header">
<th>Class</th>
<th>Constructor/Function</th>
<th>Fields/Methods</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://mlr3.mlr-org.com/reference/PredictionClassif.html"><code>PredictionClassif</code></a></td>
<td><code>classif_lrn$predict()</code></td>
<td>
<a href="https://www.rdocumentation.org/packages/mlr3measures/topics/confusion_matrix"><code>confusion_matrix()</code></a>; <code>autoplot(some_prediction_classif, type = "roc")</code>
</td>
</tr>
<tr class="even">
<td>-</td>
<td><a href="https://mlr3.mlr-org.com/reference/partition.html"><code>partition()</code></a></td>
<td>-</td>
</tr>
<tr class="odd">
<td><a href="https://mlr3.mlr-org.com/reference/Resampling.html"><code>Resampling</code></a></td>
<td><a href="https://mlr3.mlr-org.com/reference/mlr_sugar.html"><code>rsmp()</code></a></td>
<td><code>$instantiate()</code></td>
</tr>
<tr class="even">
<td><a href="https://mlr3.mlr-org.com/reference/ResampleResult.html"><code>ResampleResult</code></a></td>
<td><a href="https://mlr3.mlr-org.com/reference/resample.html"><code>resample()</code></a></td>
<td>
<code>$score()</code>; <code>$aggregate()</code>; <code>$predictions()</code>; <code>as_benchmark_result()</code>; <code>autoplot(some_resample_result, type = "roc")</code>
</td>
</tr>
<tr class="odd">
<td>-</td>
<td><a href="https://mlr3.mlr-org.com/reference/benchmark_grid.html"><code>benchmark_grid()</code></a></td>
<td>-</td>
</tr>
<tr class="even">
<td><a href="https://mlr3.mlr-org.com/reference/BenchmarkResult.html"><code>BenchmarkResult</code></a></td>
<td><a href="https://mlr3.mlr-org.com/reference/benchmark.html"><code>benchmark()</code></a></td>
<td>
<code>$aggregate()</code>; <code>$resample_result()</code>; <code>$score()</code>; <code>autoplot(some_benchmark_result, type = "roc")</code>
</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="exercises" class="level2" data-number="3.6"><h2 data-number="3.6" class="anchored" data-anchor-id="exercises">
<span class="header-section-number">3.6</span> Exercises</h2>
<ol type="1">
<li><p>Apply a repeated cross-validation resampling strategy on <code>tsk("mtcars")</code> and evaluate the performance of <code>lrn("regr.rpart")</code>. Use five repeats of three folds each. Calculate the MSE for each iteration and visualize the result. Finally, calculate the aggregated performance score.</p></li>
<li><p>Use <code>tsk("spam")</code> and five-fold CV to benchmark <code>lrn("classif.ranger")</code>, <code>lrn("classif.log_reg")</code>, and <code>lrn("classif.xgboost", nrounds = 100)</code> with respect to AUC. Which learner appears to perform best? How confident are you in your conclusion? Think about the stability of results and investigate this by re-rerunning the experiment with different seeds. What can be done to improve this?</p></li>
<li><p>A colleague reports a 93.1% classification accuracy using <code>lrn("classif.rpart")</code> on <code>tsk("penguins_simple")</code>. You want to reproduce their results and ask them about their resampling strategy. They said they used a custom three-fold CV with folds assigned as <code>factor(task$row_ids %% 3)</code>. See if you can reproduce their results.</p></li>
<li><p>(*) Program your own ROC plotting function without using <code>mlr3</code>’s <code>autoplot()</code> function. The signature of your function should be <code>my_roc_plot(task, learner, train_indices, test_indices)</code>. Your function should use the <code>$set_threshold()</code> method of <code>Prediction</code>, as well as <code>mlr3measures</code>.</p></li>
</ol></section><section id="citation" class="level2" data-number="3.7"><h2 data-number="3.7" class="anchored" data-anchor-id="citation">
<span class="header-section-number">3.7</span> Citation</h2>
<p>Please cite this chapter as:</p>
<p>Casalicchio G, Burk L. (2024). Evaluation and Benchmarking. In Bischl B, Sonabend R, Kotthoff L, Lang M, (Eds.), <em>Applied Machine Learning Using mlr3 in R</em>. CRC Press. https://mlr3book.mlr-org.com/evaluation_and_benchmarking.html.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode bibtex code-with-copy"><code class="sourceCode bibtex"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="va">@incollection</span>{<span class="ot">citekey</span>, </span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">author</span> = "<span class="st">Giuseppe Casalicchio and Lukas Burk</span>", </span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">title</span> = "<span class="st">Evaluation and Benchmarking</span>",</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">booktitle</span> = "<span class="st">Applied Machine Learning Using {m}lr3 in {R}</span>",</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">publisher</span> = "<span class="st">CRC Press</span>", <span class="st">year</span> = "<span class="st">2024</span>",</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">editor</span> = "<span class="st">Bernd Bischl and Raphael Sonabend and Lars Kotthoff and Michel Lang</span>", </span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">url</span> = "<span class="st">https://mlr3book.mlr-org.com/evaluation_and_benchmarking.html</span>"</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-bischl2012resampling" class="csl-entry" role="listitem">
Bischl, Bernd, Olaf Mersmann, Heike Trautmann, and Claus Weihs. 2012. <span>“Resampling Methods for Meta-Model Validation with Recommendations for Evolutionary Computation.”</span> <em>Evolutionary Computation</em> 20 (2): 249–75. <a href="https://doi.org/10.1162/EVCO_a_00069%20">https://doi.org/10.1162/EVCO_a_00069 </a>.
</div>
<div id="ref-davis2006relationship" class="csl-entry" role="listitem">
Davis, Jesse, and Mark Goadrich. 2006. <span>“The Relationship Between Precision-Recall and ROC Curves.”</span> In <em>Proceedings of the 23rd International Conference on Machine Learning</em>, 233–40. <a href="https://doi.org/10.1145/1143844.1143874">https://doi.org/10.1145/1143844.1143874</a>.
</div>
<div id="ref-dobbin2011" class="csl-entry" role="listitem">
Dobbin, Kevin K., and Richard M. Simon. 2011. <span>“Optimally Splitting Cases for Training and Testing High Dimensional Classifiers.”</span> <em>BMC Medical Genomics</em> 4 (1): 31. <a href="https://doi.org/10.1186/1755-8794-4-31">https://doi.org/10.1186/1755-8794-4-31</a>.
</div>
<div id="ref-hand2001simple" class="csl-entry" role="listitem">
Hand, David J, and Robert J Till. 2001. <span>“A Simple Generalisation of the Area Under the ROC Curve for Multiple Class Classification Problems.”</span> <em>Machine Learning</em> 45: 171–86. <a href="https://doi.org/10.1023/A:1010920819831">https://doi.org/10.1023/A:1010920819831</a>.
</div>
<div id="ref-japkowicz2011evaluating" class="csl-entry" role="listitem">
Japkowicz, Nathalie, and Mohak Shah. 2011. <em>Evaluating Learning Algorithms: A Classification Perspective</em>. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511921803">https://doi.org/10.1017/CBO9780511921803</a>.
</div>
<div id="ref-kim2009estimating" class="csl-entry" role="listitem">
Kim, Ji-Hyun. 2009. <span>“Estimating Classification Error Rate: Repeated Cross-Validation, Repeated Hold-Out and Bootstrap.”</span> <em>Computational Statistics &amp; Data Analysis</em> 53 (11): 3735–45. <a href="https://doi.org/10.1016/j.csda.2009.04.009">https://doi.org/10.1016/j.csda.2009.04.009</a>.
</div>
<div id="ref-kohavi1995" class="csl-entry" role="listitem">
Kohavi, Ron. 1995. <span>“A Study of Cross-Validation and Bootstrap for Accuracy Estimation and Model Selection.”</span> In <em>Proceedings of the 14th International Joint Conference on <span>Artificial</span> Intelligence - <span>Volume</span> 2</em>, 1137–43. <span>IJCAI</span>’95. <span>San Francisco, CA, USA</span>: <span>Morgan Kaufmann Publishers Inc.</span>
</div>
<div id="ref-molinaro2005prediction" class="csl-entry" role="listitem">
Molinaro, Annette M, Richard Simon, and Ruth M Pfeiffer. 2005. <span>“Prediction Error Estimation: A Comparison of Resampling Methods.”</span> <em>Bioinformatics</em> 21 (15): 3301–7. <a href="https://doi.org/10.1093/bioinformatics/bti499">https://doi.org/10.1093/bioinformatics/bti499</a>.
</div>
<div id="ref-provost2013" class="csl-entry" role="listitem">
Provost, Foster, and Tom Fawcett. 2013. <em>Data Science for Business: What You Need to Know about Data Mining and Data-Analytic Thinking</em>. O’Reilly Media.
</div>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../chapters/chapter2/data_and_basic_modeling.html" class="pagination-link" aria-label="Data and Basic Modeling">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data and Basic Modeling</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../chapters/chapter4/hyperparameter_optimization.html" class="pagination-link" aria-label="Hyperparameter Optimization">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hyperparameter Optimization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb86" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="an">aliases:</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co">  - "/evaluation_and_benchmarking.html"</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="fu"># Evaluation and Benchmarking {#sec-performance}</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_setup.qmd &gt;}}</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="in">`r chapter = "Evaluation and Benchmarking"`</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a><span class="in">`r authors(chapter)`</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>A supervised machine learning model can only be deployed in practice if it has a good <span class="in">`r index("generalization performance", aside = TRUE)`</span>, which means it generalizes well to new, unseen data.</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>Accurate estimation of the generalization performance is crucial for many aspects of machine learning application and research -- whether we want to fairly compare a novel algorithm with established ones or to find the best algorithm for a particular task.</span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>The concept of <span class="in">`r index("performance estimation")`</span> provides information on how well a model will generalize to new data and plays an important role in the context of model comparison (@sec-benchmarking), model selection, and hyperparameter tuning (@sec-optimization).</span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>Assessing the generalization performance of a model begins with selecting a <span class="in">`r index("performance measure")`</span> that is appropriate for our given task and evaluation goal.</span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>As we have seen in @sec-eval, performance measures typically compute a numeric score indicating how well the model predictions match the ground truth (though some technical measures were seen in @sec-basics-measures-tech).</span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>Once we have decided on a performance measure, the next step is to adopt a strategy that defines how to use the available data to estimate the generalization performance.</span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>Using the same data to train and test a model is a bad strategy as it would lead to an overly optimistic performance estimate.</span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>For example, a model that is overfitted (fit too closely to the data) could make perfect predictions on training data simply by memorizing it and then only make random guesses for new data.</span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a>In @sec-basics-partition we introduced <span class="in">`r ref("partition()")`</span>, which splits a dataset into <span class="in">`r index('training data')`</span> -- data for training the model -- and <span class="in">`r index('test data')`</span> --  data for testing the model and estimating the generalization performance, this is known as the holdout strategy (@sec-holdout-scoring) and is where we will begin this chapter.</span>
<span id="cb86-23"><a href="#cb86-23" aria-hidden="true" tabindex="-1"></a>We will then consider more advanced strategies for assessing the generalization performance (@sec-resampling), look at robust methods for comparing models (@sec-benchmarking), and finally will discuss specialized performance measures for binary classification (@sec-roc).</span>
<span id="cb86-24"><a href="#cb86-24" aria-hidden="true" tabindex="-1"></a>For an in-depth overview of measures and performance estimation, we recommend @japkowicz2011evaluating.</span>
<span id="cb86-25"><a href="#cb86-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-26"><a href="#cb86-26" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb86-27"><a href="#cb86-27" aria-hidden="true" tabindex="-1"></a><span class="fu">## Resampling Does Not Avoid Model Overfitting</span></span>
<span id="cb86-28"><a href="#cb86-28" aria-hidden="true" tabindex="-1"></a>A common **misunderstanding** is that holdout and other more advanced resampling strategies can prevent model overfitting.</span>
<span id="cb86-29"><a href="#cb86-29" aria-hidden="true" tabindex="-1"></a>In fact, these methods just make overfitting visible as we can separately evaluate train/test performance.</span>
<span id="cb86-30"><a href="#cb86-30" aria-hidden="true" tabindex="-1"></a>Resampling strategies also allow us to make (nearly) unbiased estimations of the generalization error.</span>
<span id="cb86-31"><a href="#cb86-31" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-32"><a href="#cb86-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-33"><a href="#cb86-33" aria-hidden="true" tabindex="-1"></a><span class="fu">## Holdout and Scoring {#sec-holdout-scoring}</span></span>
<span id="cb86-34"><a href="#cb86-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-35"><a href="#cb86-35" aria-hidden="true" tabindex="-1"></a>An important goal of ML is to learn a model that can then be used to make predictions about new data.</span>
<span id="cb86-36"><a href="#cb86-36" aria-hidden="true" tabindex="-1"></a>For this model to be as accurate as possible, we would ideally train it on as much data as is available.</span>
<span id="cb86-37"><a href="#cb86-37" aria-hidden="true" tabindex="-1"></a>However, data is limited and as we have discussed we cannot train and test a model on the same data.</span>
<span id="cb86-38"><a href="#cb86-38" aria-hidden="true" tabindex="-1"></a>In practice, one would usually create an <span class="in">`r index('intermediate model', aside = TRUE)`</span>, which is trained on a subset of the available data and then tested on the remainder of the data.</span>
<span id="cb86-39"><a href="#cb86-39" aria-hidden="true" tabindex="-1"></a>The performance of this intermediate model, obtained by comparing the model predictions to the ground truth, is an estimate of the generalization performance of the final model, which is the model fitted on all data.</span>
<span id="cb86-40"><a href="#cb86-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-41"><a href="#cb86-41" aria-hidden="true" tabindex="-1"></a>The <span class="in">`r index('holdout', aside = TRUE)`</span> strategy is a simple method to create this split between training and testing datasets, whereby the original data is split into two datasets using a defined ratio.</span>
<span id="cb86-42"><a href="#cb86-42" aria-hidden="true" tabindex="-1"></a>Ideally, the training dataset should be as large as possible so the intermediate model represents the final model as well possible.</span>
<span id="cb86-43"><a href="#cb86-43" aria-hidden="true" tabindex="-1"></a>If the training data is too small, the intermediate model is unlikely to perform as well as the final model, resulting in a pessimistically biased performance estimate.</span>
<span id="cb86-44"><a href="#cb86-44" aria-hidden="true" tabindex="-1"></a>On the other hand, if the training data is too large, then we will not have a reliable estimate of the generalization performance due to high variance resulting from small test data.</span>
<span id="cb86-45"><a href="#cb86-45" aria-hidden="true" tabindex="-1"></a>As a rule of thumb, it is common to use 2/3 of the data for training and 1/3 for testing as this provides a reasonable trade-off between bias and variance of the generalization performance estimate <span class="co">[</span><span class="ot">@kohavi1995;@dobbin2011</span><span class="co">]</span>.</span>
<span id="cb86-46"><a href="#cb86-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-47"><a href="#cb86-47" aria-hidden="true" tabindex="-1"></a>In @sec-basics, we used <span class="in">`r ref("partition()")`</span> to apply the holdout method to a <span class="in">`r ref("Task")`</span> object.</span>
<span id="cb86-48"><a href="#cb86-48" aria-hidden="true" tabindex="-1"></a>To recap, let us split <span class="in">`tsk("penguins")`</span> with a 2/3 holdout (default split):</span>
<span id="cb86-49"><a href="#cb86-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-50"><a href="#cb86-50" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-003}</span></span>
<span id="cb86-51"><a href="#cb86-51" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_penguins = tsk("penguins")</span></span>
<span id="cb86-52"><a href="#cb86-52" aria-hidden="true" tabindex="-1"></a><span class="in">splits = partition(tsk_penguins)</span></span>
<span id="cb86-53"><a href="#cb86-53" aria-hidden="true" tabindex="-1"></a><span class="in">lrn_rpart = lrn("classif.rpart")</span></span>
<span id="cb86-54"><a href="#cb86-54" aria-hidden="true" tabindex="-1"></a><span class="in">lrn_rpart$train(tsk_penguins, splits$train)</span></span>
<span id="cb86-55"><a href="#cb86-55" aria-hidden="true" tabindex="-1"></a><span class="in">prediction = lrn_rpart$predict(tsk_penguins, splits$test)</span></span>
<span id="cb86-56"><a href="#cb86-56" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-57"><a href="#cb86-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-58"><a href="#cb86-58" aria-hidden="true" tabindex="-1"></a>We can now estimate the generalization performance of a final model by evaluating the quality of the predictions from our intermediate model.</span>
<span id="cb86-59"><a href="#cb86-59" aria-hidden="true" tabindex="-1"></a>As we have seen in @sec-eval, this is simply a case of choosing one or more measures and passing them to the <span class="in">`$score()`</span> function.</span>
<span id="cb86-60"><a href="#cb86-60" aria-hidden="true" tabindex="-1"></a>So to estimate the accuracy of our final model we would pass the accuracy measure to our intermediate model:</span>
<span id="cb86-61"><a href="#cb86-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-64"><a href="#cb86-64" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-65"><a href="#cb86-65" aria-hidden="true" tabindex="-1"></a>prediction<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"classif.acc"</span>))</span>
<span id="cb86-66"><a href="#cb86-66" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-67"><a href="#cb86-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-68"><a href="#cb86-68" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb86-69"><a href="#cb86-69" aria-hidden="true" tabindex="-1"></a><span class="fu">## Permuting Observations for Performance Estimation</span></span>
<span id="cb86-70"><a href="#cb86-70" aria-hidden="true" tabindex="-1"></a>When splitting data it is essential to permute observations before, to remove any information that is encoded in data ordering.</span>
<span id="cb86-71"><a href="#cb86-71" aria-hidden="true" tabindex="-1"></a>The order of data is often informative in real-world datasets, for example hospital data will likely be ordered by time of patient admission.</span>
<span id="cb86-72"><a href="#cb86-72" aria-hidden="true" tabindex="-1"></a>In <span class="in">`tsk("penguins")`</span>, the data is ordered such that the first 152 rows all have the label 'Adelie', the next 68 have the label 'Chinstrap', and the final 124 have the label 'Gentoo'; so if we did not permute the data we could end up with a model that is only trained on one or two species.</span>
<span id="cb86-73"><a href="#cb86-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-74"><a href="#cb86-74" aria-hidden="true" tabindex="-1"></a><span class="in">`partition()`</span> and all resampling strategies discussed below automatically randomly split the data to prevent any biases (so do not forget to set a seed for reproducibility).</span>
<span id="cb86-75"><a href="#cb86-75" aria-hidden="true" tabindex="-1"></a>Data *within* each set may still be ordered because of implementation details, but this is not a problem as long as the data is shuffled between sets.</span>
<span id="cb86-76"><a href="#cb86-76" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-77"><a href="#cb86-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-78"><a href="#cb86-78" aria-hidden="true" tabindex="-1"></a>Many performance measures are based on 'decomposable' losses, which means they compute the differences between the predicted values and ground truth values first on an observation level and then aggregate the individual loss values over the test set into a single numeric score.</span>
<span id="cb86-79"><a href="#cb86-79" aria-hidden="true" tabindex="-1"></a>For example, the classification accuracy compares whether the predicted values from the <span class="in">`response`</span> column have the same value as the ground truth values from the <span class="in">`truth`</span> column of the <span class="in">`r ref("Prediction")`</span> object.</span>
<span id="cb86-80"><a href="#cb86-80" aria-hidden="true" tabindex="-1"></a>Hence, for each observation, the decomposable loss takes either value <span class="in">`1`</span> (if <span class="in">`response`</span> and <span class="in">`truth`</span> have the same value) or <span class="in">`0`</span> otherwise.</span>
<span id="cb86-81"><a href="#cb86-81" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$score()`</span> method summarizes these individual loss values into a an average value -- the percentage where our prediction was correct.</span>
<span id="cb86-82"><a href="#cb86-82" aria-hidden="true" tabindex="-1"></a>Other performance measures that are not decomposable instead act on a set of observations, we will return to this in detail when we look at the AUC measure in @sec-roc.</span>
<span id="cb86-83"><a href="#cb86-83" aria-hidden="true" tabindex="-1"></a>@fig-score illustrates the input-output behavior of the <span class="in">`$score()`</span> method, we will return to this when we turn to more complex evaluation strategies.</span>
<span id="cb86-84"><a href="#cb86-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-85"><a href="#cb86-85" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-017, out.width = "80%"}</span></span>
<span id="cb86-86"><a href="#cb86-86" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-87"><a href="#cb86-87" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-score</span></span>
<span id="cb86-88"><a href="#cb86-88" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustration of the `$score()` method which aggregates predictions of multiple observations contained in a prediction object into a single numeric score"</span></span>
<span id="cb86-89"><a href="#cb86-89" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: A funnel-shaped diagram where the far left box shows the output from a classification prediction object with row_ids, truth, and response columns. Next to this is a box that just says '$score()', which then passes to the right in a funnel shape to a box that says 'classif.acc 0.920354'.</span></span>
<span id="cb86-90"><a href="#cb86-90" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-3")</span></span>
<span id="cb86-91"><a href="#cb86-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-92"><a href="#cb86-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-93"><a href="#cb86-93" aria-hidden="true" tabindex="-1"></a><span class="fu">## Resampling {#sec-resampling}</span></span>
<span id="cb86-94"><a href="#cb86-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-95"><a href="#cb86-95" aria-hidden="true" tabindex="-1"></a><span class="in">`r index("Resampling")`</span> strategies repeatedly split all available data into multiple training and test sets, with one repetition corresponding to what is called a 'resampling iteration' in <span class="in">`r mlr3`</span>.</span>
<span id="cb86-96"><a href="#cb86-96" aria-hidden="true" tabindex="-1"></a>An intermediate model is then trained on each training set and the test set is used to measure the performance in each resampling iteration.</span>
<span id="cb86-97"><a href="#cb86-97" aria-hidden="true" tabindex="-1"></a>The generalization performance is finally estimated by aggregating the performance scores over multiple resampling iterations (@fig-ml-abstraction).</span>
<span id="cb86-98"><a href="#cb86-98" aria-hidden="true" tabindex="-1"></a>By repeating the data splitting process, data points are repeatedly used for both training and testing, allowing more efficient use of all available data for performance estimation.</span>
<span id="cb86-99"><a href="#cb86-99" aria-hidden="true" tabindex="-1"></a>Furthermore, a high number of resampling iterations can reduce the variance in our scores and thus result in a more reliable performance estimate.</span>
<span id="cb86-100"><a href="#cb86-100" aria-hidden="true" tabindex="-1"></a>This means that the performance estimate is less likely to be affected by an 'unlucky' split (e.g., a split that does not reflect the original data distribution).</span>
<span id="cb86-101"><a href="#cb86-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-102"><a href="#cb86-102" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-002, echo=FALSE}</span></span>
<span id="cb86-103"><a href="#cb86-103" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-ml-abstraction</span></span>
<span id="cb86-104"><a href="#cb86-104" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "A general abstraction of the performance estimation process. The available data is (repeatedly) split into training data and test data (data splitting / resampling process). The learner is trained on each training dataset and produces intermediate models (learning process). Each intermediate model makes predictions based on the features in the test data. The performance measure compares these predictions with the ground truth from the test data and computes a performance value for each test dataset. All performance values are aggregated into a scalar value to estimate the generalization performance (evaluation process)."</span></span>
<span id="cb86-105"><a href="#cb86-105" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "A flowchart-like diagram with 3 overlapping boxes. Left box has the caption 'Data splitting / resampling process', upper right box has caption 'Learning process', and lower right box has caption 'Evaluation process'. The process starts in the left box with 'Data' and an arrow to 'Resampling Strategy', which separates into two elements stacked vertically: 'Train Set(s)' above and 'Test Set(s)' below. The 'Train set(s)' element leads to a 'Learner' box, which is inside the larger 'Learning Process' box. A box that says 'Hyperparameters' also sits within the 'Learning Process' and is connected with an arrow also pointing to 'Learner'. An arrow points from the 'Learner' to a stack of 'Intermediate Model(s)'. One thick arrow goes down into the yellow box to a stack of 'Prediction(s)'. An arrow goes from there to 'Performance measure'. The 'Test set(s)' from earlier also have an arrow to 'Performance measure'. From there, a thick arrow goes to 'Performance Value(s)', which has a final dashed arrow to 'Aggregated Performance'."</span></span>
<span id="cb86-106"><a href="#cb86-106" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-4")</span></span>
<span id="cb86-107"><a href="#cb86-107" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-108"><a href="#cb86-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-109"><a href="#cb86-109" aria-hidden="true" tabindex="-1"></a>A variety of resampling strategies exist, each with its advantages and disadvantages, which depend on the number of available samples, the task complexity, and the type of model.</span>
<span id="cb86-110"><a href="#cb86-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-111"><a href="#cb86-111" aria-hidden="true" tabindex="-1"></a>A very common strategy is k-fold <span class="in">`r index("cross-validation", aside = TRUE)`</span> (CV), which randomly partitions the data into $k$ non-overlapping subsets, called folds (@fig-cv-illustration).</span>
<span id="cb86-112"><a href="#cb86-112" aria-hidden="true" tabindex="-1"></a>The $k$ models are always trained on $k-1$ of the folds, with the remaining fold being used as test data; this process is repeated until each fold has acted exactly once as test set.</span>
<span id="cb86-113"><a href="#cb86-113" aria-hidden="true" tabindex="-1"></a>Finally, the $k$ performance estimates from each fold are aggregated, usually by averaging.</span>
<span id="cb86-114"><a href="#cb86-114" aria-hidden="true" tabindex="-1"></a>CV guarantees that each observation will be used exactly once in a test set, making efficient use of the available data for performance estimation.</span>
<span id="cb86-115"><a href="#cb86-115" aria-hidden="true" tabindex="-1"></a>Common values for $k$ are 5 and 10, meaning each training set will consist of 4/5 or 9/10 of the original data, respectively.</span>
<span id="cb86-116"><a href="#cb86-116" aria-hidden="true" tabindex="-1"></a>Several variations of CV exist, including repeated k-fold cross-validation\index{cross-validation!repeated k-fold} where the k-fold process is repeated multiple times, and <span class="in">`r index('leave-one-out cross-validation', "leave-one-out", parent = "cross-validation")`</span> (LOO-CV) where the number of folds is equal to the number of observations, leading to the test set in each fold consisting of only one observation.</span>
<span id="cb86-117"><a href="#cb86-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-118"><a href="#cb86-118" aria-hidden="true" tabindex="-1"></a><span class="in">`r index("Subsampling", aside = TRUE)`</span> and <span class="in">`r index("bootstrapping")`</span> are two related resampling strategies.</span>
<span id="cb86-119"><a href="#cb86-119" aria-hidden="true" tabindex="-1"></a>Subsampling randomly selects a given ratio (4/5 and 9/10 are common) of the data for the training dataset where each observation in the dataset is drawn *without replacement* from the original dataset.</span>
<span id="cb86-120"><a href="#cb86-120" aria-hidden="true" tabindex="-1"></a>The model is trained on this data and then tested on the remaining data, and this process is repeated $k$ times.</span>
<span id="cb86-121"><a href="#cb86-121" aria-hidden="true" tabindex="-1"></a>This differs from k-fold CV as the subsets of test data may be overlapping.</span>
<span id="cb86-122"><a href="#cb86-122" aria-hidden="true" tabindex="-1"></a>Bootstrapping follows the same process as subsampling but data is drawn *with replacement* from the original dataset. Usually the number of bootstrap samples equals the size of the original dataset.</span>
<span id="cb86-123"><a href="#cb86-123" aria-hidden="true" tabindex="-1"></a>This means an observation could be selected multiple times (and thus duplicated) in the training data (but never more than once per test dataset).</span>
<span id="cb86-124"><a href="#cb86-124" aria-hidden="true" tabindex="-1"></a>On average, $1 - e^{-1} \approx 63.2\%$ of the data points will be contained in the training set during bootstrapping, referred to as "in-bag" samples (the other 36.8% are known as "out-of-bag" samples).</span>
<span id="cb86-125"><a href="#cb86-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-126"><a href="#cb86-126" aria-hidden="true" tabindex="-1"></a>Note that terminology regarding resampling strategies is not consistent across the literature, for example, subsampling is sometimes referred to as "repeated holdout" \index{repeated holdout|see{subsampling}} or "Monte Carlo cross-validation"\index{Monte Carlo cross-validation|see{subsampling}}.</span>
<span id="cb86-127"><a href="#cb86-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-128"><a href="#cb86-128" aria-hidden="true" tabindex="-1"></a>The choice of the resampling strategy usually depends on the specific task at hand and the goals of the performance assessment, but some rules of thumb are available.</span>
<span id="cb86-129"><a href="#cb86-129" aria-hidden="true" tabindex="-1"></a>If the available data is fairly small ($N \leq 500$), repeated cross-validation with a large number of repetitions can be used to keep the variance of the performance estimates low (10 folds and 10 repetitions is a good place to start).</span>
<span id="cb86-130"><a href="#cb86-130" aria-hidden="true" tabindex="-1"></a>Traditionally, LOO-CV has also been recommended for these small sample size regimes, but this estimation scheme is quite expensive (except in special cases where computational shortcuts exist) and (counterintuitively) suffers from quite high variance. Furthermore, LOO-CV is also problematic in imbalanced binary classification tasks as concepts such as stratification (@sec-strat-group) cannot be applied.</span>
<span id="cb86-131"><a href="#cb86-131" aria-hidden="true" tabindex="-1"></a>For the $500 \leq N \leq 50000$ range, 5- to 10-fold CV is generally recommended.</span>
<span id="cb86-132"><a href="#cb86-132" aria-hidden="true" tabindex="-1"></a>In general, the larger the dataset, the fewer splits are required, yet sample-size issues can still occur, e.g., due to imbalanced data.</span>
<span id="cb86-133"><a href="#cb86-133" aria-hidden="true" tabindex="-1"></a>For settings where one is more interested in proper inference (such as through statistical performance tests or confidence intervals) than bare point estimators of performance, bootstrapping and subsampling are often considered, usually with a higher number of iterations. Bootstrapping has become less common, as having repeated observations in training data can lead to problems in some machine learning setups, especially when combined with model selection methods and nested resampling (as duplicated observations can then end up simultaneously in training and test sets in nested schemes). Also note that in all of these common and simple schemes, resampling performance estimates are not independent, as models are fitted on overlapping training data, making proper inference less than trivial, but a proper treatment of these issues is out of scope for us here. For further details and critical discussion we refer to the literature, e.g., @molinaro2005prediction, @kim2009estimating, and @bischl2012resampling.</span>
<span id="cb86-134"><a href="#cb86-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-135"><a href="#cb86-135" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- Source: https://docs.google.com/presentation/d/1BJXJ365C9TWelojV93IeQJAtEiD3uZMFSfkhzgYH-n8/edit?usp=sharing --&gt;</span></span>
<span id="cb86-136"><a href="#cb86-136" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-007, echo=FALSE}</span></span>
<span id="cb86-137"><a href="#cb86-137" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-cv-illustration</span></span>
<span id="cb86-138"><a href="#cb86-138" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustration of a three-fold cross-validation."</span></span>
<span id="cb86-139"><a href="#cb86-139" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "Complex flow chart in roughly three rows. Top row (Iteration 1) shows Dtrain split into two light blue boxes representing training data and pointing to a 'Learner', which points to a 'Model'. A dark blue box representing test data points to the same 'Model' as well as 'Measure'. 'Model' points to 'Prediction' which also points to 'Measure', which then points to 'Performance', which has an arrow to 'Averaged Performance'. In rows two and three the same process is inferred except with different boxes in dark and light blue so that each box has been dark blue exactly once across all three iterations."</span></span>
<span id="cb86-140"><a href="#cb86-140" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-6")</span></span>
<span id="cb86-141"><a href="#cb86-141" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-142"><a href="#cb86-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-143"><a href="#cb86-143" aria-hidden="true" tabindex="-1"></a>In the rest of this section, we will go through querying and constructing resampling strategies in <span class="in">`mlr3`</span>, instantiating train-test splits, and then performing resampling on learners.</span>
<span id="cb86-144"><a href="#cb86-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-145"><a href="#cb86-145" aria-hidden="true" tabindex="-1"></a><span class="fu">### Constructing a Resampling Strategy {#sec-resampling-construct}</span></span>
<span id="cb86-146"><a href="#cb86-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-147"><a href="#cb86-147" aria-hidden="true" tabindex="-1"></a>All implemented resampling strategies are stored in the <span class="in">`r ref("mlr_resamplings")`</span> dictionary.</span>
<span id="cb86-148"><a href="#cb86-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-149"><a href="#cb86-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-008}</span></span>
<span id="cb86-150"><a href="#cb86-150" aria-hidden="true" tabindex="-1"></a><span class="in">as.data.table(mlr_resamplings)</span></span>
<span id="cb86-151"><a href="#cb86-151" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-152"><a href="#cb86-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-153"><a href="#cb86-153" aria-hidden="true" tabindex="-1"></a>The <span class="in">`params`</span> column shows the parameters of each resampling strategy (e.g., the train-test splitting <span class="in">`ratio`</span> or the number of <span class="in">`repeats`</span>) and <span class="in">`iters`</span> displays the number of performed resampling iterations by default.</span>
<span id="cb86-154"><a href="#cb86-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-155"><a href="#cb86-155" aria-hidden="true" tabindex="-1"></a><span class="in">`r ref("Resampling", aside = TRUE)`</span> objects can be constructed by passing the strategy 'key' to the sugar function <span class="in">`r ref("rsmp()", aside = TRUE)`</span>.</span>
<span id="cb86-156"><a href="#cb86-156" aria-hidden="true" tabindex="-1"></a>For example, to construct the holdout strategy with a 4/5 split (2/3 by default):</span>
<span id="cb86-157"><a href="#cb86-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-158"><a href="#cb86-158" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-009}</span></span>
<span id="cb86-159"><a href="#cb86-159" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp("holdout", ratio = 0.8)</span></span>
<span id="cb86-160"><a href="#cb86-160" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-161"><a href="#cb86-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-162"><a href="#cb86-162" aria-hidden="true" tabindex="-1"></a>Parameters for objects inheriting from <span class="in">`Resampling`</span> work in the same way as measures and learners and can be set, retrieved, and updated accordingly:</span>
<span id="cb86-163"><a href="#cb86-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-164"><a href="#cb86-164" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-011}</span></span>
<span id="cb86-165"><a href="#cb86-165" aria-hidden="true" tabindex="-1"></a><span class="in"># three-fold CV</span></span>
<span id="cb86-166"><a href="#cb86-166" aria-hidden="true" tabindex="-1"></a><span class="in">cv3 = rsmp("cv", folds = 3)</span></span>
<span id="cb86-167"><a href="#cb86-167" aria-hidden="true" tabindex="-1"></a><span class="in"># Subsampling with 3 repeats and 9/10 ratio</span></span>
<span id="cb86-168"><a href="#cb86-168" aria-hidden="true" tabindex="-1"></a><span class="in">ss390 = rsmp("subsampling", repeats = 3, ratio = 0.9)</span></span>
<span id="cb86-169"><a href="#cb86-169" aria-hidden="true" tabindex="-1"></a><span class="in"># 2-repeats 5-fold CV</span></span>
<span id="cb86-170"><a href="#cb86-170" aria-hidden="true" tabindex="-1"></a><span class="in">rcv25 = rsmp("repeated_cv", repeats = 2, folds = 5)</span></span>
<span id="cb86-171"><a href="#cb86-171" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-172"><a href="#cb86-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-173"><a href="#cb86-173" aria-hidden="true" tabindex="-1"></a>When a <span class="in">`"Resampling"`</span> object is constructed, it is simply a definition for how the data splitting process will be performed on the task when running the resampling strategy.</span>
<span id="cb86-174"><a href="#cb86-174" aria-hidden="true" tabindex="-1"></a>However, it is possible to manually instantiate a resampling strategy, i.e., generate all train-test splits, by calling the <span class="in">`$instantiate()`</span>\index{\texttt{Resampling}!\texttt{\$instantiate()}}<span class="co">[</span><span class="ot">`$instantiate()`</span><span class="co">]</span>{.aside} method on a given task.</span>
<span id="cb86-175"><a href="#cb86-175" aria-hidden="true" tabindex="-1"></a>So carrying on our <span class="in">`tsk("penguins")`</span> example we can instantiate the three-fold CV object and then view the row indices of the data selected for training and testing each fold using <span class="in">`$train_set()`</span> and <span class="in">`$test_set()`</span> respectively:</span>
<span id="cb86-176"><a href="#cb86-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-177"><a href="#cb86-177" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-012}</span></span>
<span id="cb86-178"><a href="#cb86-178" aria-hidden="true" tabindex="-1"></a><span class="in">cv3$instantiate(tsk_penguins)</span></span>
<span id="cb86-179"><a href="#cb86-179" aria-hidden="true" tabindex="-1"></a><span class="in"># first 5 observations in first training set</span></span>
<span id="cb86-180"><a href="#cb86-180" aria-hidden="true" tabindex="-1"></a><span class="in">cv3$train_set(1)[1:5]</span></span>
<span id="cb86-181"><a href="#cb86-181" aria-hidden="true" tabindex="-1"></a><span class="in"># first 5 observations in third test set</span></span>
<span id="cb86-182"><a href="#cb86-182" aria-hidden="true" tabindex="-1"></a><span class="in">cv3$test_set(3)[1:5]</span></span>
<span id="cb86-183"><a href="#cb86-183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-184"><a href="#cb86-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-185"><a href="#cb86-185" aria-hidden="true" tabindex="-1"></a>When the aim is to fairly compare multiple learners, best practice dictates that all learners being compared use the same training data to build a model and that they use the same test data to evaluate the model performance.</span>
<span id="cb86-186"><a href="#cb86-186" aria-hidden="true" tabindex="-1"></a>Resampling strategies are instantiated automatically for you when using the <span class="in">`resample()`</span> method, which we will discuss next.</span>
<span id="cb86-187"><a href="#cb86-187" aria-hidden="true" tabindex="-1"></a>Therefore, manually instantiating resampling strategies is rarely required but might be useful for debugging or digging deeper into a model's performance.</span>
<span id="cb86-188"><a href="#cb86-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-189"><a href="#cb86-189" aria-hidden="true" tabindex="-1"></a><span class="fu">### Resampling Experiments {#sec-resampling-exec}</span></span>
<span id="cb86-190"><a href="#cb86-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-191"><a href="#cb86-191" aria-hidden="true" tabindex="-1"></a>The <span class="in">`r ref("resample()", aside = TRUE)`</span> function takes a given <span class="in">`Task`</span>, <span class="in">`Learner`</span>, and <span class="in">`r ref("Resampling")`</span> object to run the given resampling strategy.</span>
<span id="cb86-192"><a href="#cb86-192" aria-hidden="true" tabindex="-1"></a><span class="in">`resample()`</span> repeatedly fits a model on training sets, makes predictions on the corresponding test sets and stores them in a <span class="in">`r ref("ResampleResult", aside = TRUE)`</span> object, which contains all the information needed to estimate the generalization performance.</span>
<span id="cb86-193"><a href="#cb86-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-194"><a href="#cb86-194" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-013}</span></span>
<span id="cb86-195"><a href="#cb86-195" aria-hidden="true" tabindex="-1"></a><span class="in">rr = resample(tsk_penguins, lrn_rpart, cv3)</span></span>
<span id="cb86-196"><a href="#cb86-196" aria-hidden="true" tabindex="-1"></a><span class="in">rr</span></span>
<span id="cb86-197"><a href="#cb86-197" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-198"><a href="#cb86-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-199"><a href="#cb86-199" aria-hidden="true" tabindex="-1"></a>Each row of the output corresponds to one of the three iterations/folds.</span>
<span id="cb86-200"><a href="#cb86-200" aria-hidden="true" tabindex="-1"></a>As with <span class="in">`Prediction`</span> objects, we can calculate the score *for each iteration* with <span class="in">`$score()`</span>:</span>
<span id="cb86-201"><a href="#cb86-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-202"><a href="#cb86-202" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-014}</span></span>
<span id="cb86-203"><a href="#cb86-203" aria-hidden="true" tabindex="-1"></a><span class="in">acc = rr$score(msr("classif.ce"))</span></span>
<span id="cb86-204"><a href="#cb86-204" aria-hidden="true" tabindex="-1"></a><span class="in">acc[, .(iteration, classif.ce)]</span></span>
<span id="cb86-205"><a href="#cb86-205" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-206"><a href="#cb86-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-207"><a href="#cb86-207" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb86-208"><a href="#cb86-208" aria-hidden="true" tabindex="-1"></a><span class="fu">## Evaluating Train Sets</span></span>
<span id="cb86-209"><a href="#cb86-209" aria-hidden="true" tabindex="-1"></a>By default, <span class="in">`$score()`</span> evaluates the performance in the *test* sets in each iteration, however, you could evaluate the *train* set performance with <span class="in">`$score(predict_sets = "train")`</span>.</span>
<span id="cb86-210"><a href="#cb86-210" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-211"><a href="#cb86-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-212"><a href="#cb86-212" aria-hidden="true" tabindex="-1"></a>While <span class="in">`$score()`</span> returns the performance in each evaluation, <span class="in">`r index('$aggregate()', parent = "Learner", aside = TRUE, code = TRUE)`</span>, returns the aggregated score across all resampling iterations.</span>
<span id="cb86-213"><a href="#cb86-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-216"><a href="#cb86-216" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-217"><a href="#cb86-217" aria-hidden="true" tabindex="-1"></a>rr<span class="sc">$</span><span class="fu">aggregate</span>(<span class="fu">msr</span>(<span class="st">"classif.ce"</span>))</span>
<span id="cb86-218"><a href="#cb86-218" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-219"><a href="#cb86-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-220"><a href="#cb86-220" aria-hidden="true" tabindex="-1"></a>By default, the majority of measures will aggregate scores using a <span class="in">`r index("macro average")`</span>, which first calculates the measure in each resampling iteration separately, and then averages these scores across all iterations.</span>
<span id="cb86-221"><a href="#cb86-221" aria-hidden="true" tabindex="-1"></a>However, it is also possible to aggregate scores using a <span class="in">`r index("micro average")`</span>, which pools predictions across resampling iterations into one <span class="in">`r ref("Prediction")`</span> object and then computes the measure on this directly:</span>
<span id="cb86-222"><a href="#cb86-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-223"><a href="#cb86-223" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-015}</span></span>
<span id="cb86-224"><a href="#cb86-224" aria-hidden="true" tabindex="-1"></a><span class="in">rr$aggregate(msr("classif.ce", average = "micro"))</span></span>
<span id="cb86-225"><a href="#cb86-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-226"><a href="#cb86-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-227"><a href="#cb86-227" aria-hidden="true" tabindex="-1"></a>We can see a *small* difference between the two methods.</span>
<span id="cb86-228"><a href="#cb86-228" aria-hidden="true" tabindex="-1"></a>Classification error is a decomposable loss (@sec-holdout-scoring), in fact, if the test sets all had the same size then the micro and macro methods would be identical (see box below).</span>
<span id="cb86-229"><a href="#cb86-229" aria-hidden="true" tabindex="-1"></a>For errors like AUC, which are defined across the set of observations, the difference between micro- and macro-averaging will be larger.</span>
<span id="cb86-230"><a href="#cb86-230" aria-hidden="true" tabindex="-1"></a>The default type of aggregation method can be found by querying the <span class="in">`$average`</span> field of a <span class="in">`r ref("Measure")`</span> object.</span>
<span id="cb86-231"><a href="#cb86-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-232"><a href="#cb86-232" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb86-233"><a href="#cb86-233" aria-hidden="true" tabindex="-1"></a><span class="fu">## Macro- and Micro-Averaging</span></span>
<span id="cb86-234"><a href="#cb86-234" aria-hidden="true" tabindex="-1"></a>As a simple example to explain macro- and micro-averaging, consider the difference between taking the mean of a vector (micro) compared to the mean of two group-wise means (macro):</span>
<span id="cb86-235"><a href="#cb86-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-238"><a href="#cb86-238" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-239"><a href="#cb86-239" aria-hidden="true" tabindex="-1"></a><span class="co"># macro</span></span>
<span id="cb86-240"><a href="#cb86-240" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">mean</span>(<span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">9</span>)), <span class="fu">mean</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">5</span>)))</span>
<span id="cb86-241"><a href="#cb86-241" aria-hidden="true" tabindex="-1"></a><span class="co"># micro</span></span>
<span id="cb86-242"><a href="#cb86-242" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">1</span>, <span class="dv">5</span>))</span>
<span id="cb86-243"><a href="#cb86-243" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-244"><a href="#cb86-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-245"><a href="#cb86-245" aria-hidden="true" tabindex="-1"></a>In the example shown in the main text where we used <span class="in">`tsk("penguins")`</span>, there is a difference in the classification error between micro and macro methods because the dataset has 344 rows, which is not divisible by three (the number of folds), hence the test sets are not of an equal size.</span>
<span id="cb86-246"><a href="#cb86-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-247"><a href="#cb86-247" aria-hidden="true" tabindex="-1"></a>Note that the terms "macro-averaging" and "micro-averaging" are not used consistently in the literature, and sometimes refer to different concepts, e.g., the way in which the performance is aggregated across classes in a multi-class classification task.</span>
<span id="cb86-248"><a href="#cb86-248" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-249"><a href="#cb86-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-250"><a href="#cb86-250" aria-hidden="true" tabindex="-1"></a>The aggregated score returned by <span class="in">`$aggregate()`</span> estimates the generalization performance of our selected learner on the given task using the resampling strategy defined in the <span class="in">`Resampling`</span> object.</span>
<span id="cb86-251"><a href="#cb86-251" aria-hidden="true" tabindex="-1"></a>While we are usually interested in this aggregated score, it can be useful to look at the individual performance values of each resampling iteration (as returned by the <span class="in">`$score()`</span> method) as well, e.g., to see if any of the iterations lead to very different performance results.</span>
<span id="cb86-252"><a href="#cb86-252" aria-hidden="true" tabindex="-1"></a>@fig-score-aggregate-resampling visualizes the relationship between <span class="in">`$score()`</span> and <span class="in">`$aggregate()`</span> for a small example based on the <span class="in">`"penguins"`</span> task.</span>
<span id="cb86-253"><a href="#cb86-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-254"><a href="#cb86-254" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-017}</span></span>
<span id="cb86-255"><a href="#cb86-255" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-256"><a href="#cb86-256" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-score-aggregate-resampling</span></span>
<span id="cb86-257"><a href="#cb86-257" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "An example of the difference between `$score()` and `$aggregate()`: The former aggregates predictions to a single score within each resampling iteration, and the latter aggregates scores across all resampling iterations."</span></span>
<span id="cb86-258"><a href="#cb86-258" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "A funnel-shaped diagram. Left: Each resampling iteration contains multiple rows of predictions, with 3 iterations total. Middle: $score() reduces those to one performance score per resampling iteration, which leaves 3 scores. Right: $aggregate() reduces predictions across all resampling iterations to a single performance score."</span></span>
<span id="cb86-259"><a href="#cb86-259" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-5")</span></span>
<span id="cb86-260"><a href="#cb86-260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-261"><a href="#cb86-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-262"><a href="#cb86-262" aria-hidden="true" tabindex="-1"></a>To visualize the resampling results, you can use the <span class="in">`r ref("mlr3viz::autoplot.ResampleResult()")`</span> function to plot scores across folds as boxplots or histograms (@fig-resamp-viz).</span>
<span id="cb86-263"><a href="#cb86-263" aria-hidden="true" tabindex="-1"></a>Histograms can be useful to visually gauge the variance of the performance results across resampling iterations, whereas boxplots are often used when multiple learners are compared side-by-side (see @sec-benchmarking).</span>
<span id="cb86-264"><a href="#cb86-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-265"><a href="#cb86-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-266"><a href="#cb86-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-269"><a href="#cb86-269" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-270"><a href="#cb86-270" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb86-271"><a href="#cb86-271" aria-hidden="true" tabindex="-1"></a>rr <span class="ot">=</span> <span class="fu">resample</span>(tsk_penguins, lrn_rpart, <span class="fu">rsmp</span>(<span class="st">"cv"</span>, <span class="at">folds =</span> <span class="dv">10</span>))</span>
<span id="cb86-272"><a href="#cb86-272" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(rr, <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>), <span class="at">type =</span> <span class="st">"boxplot"</span>)</span>
<span id="cb86-273"><a href="#cb86-273" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(rr, <span class="at">measure =</span> <span class="fu">msr</span>(<span class="st">"classif.acc"</span>), <span class="at">type =</span> <span class="st">"histogram"</span>)</span>
<span id="cb86-274"><a href="#cb86-274" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-275"><a href="#cb86-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-276"><a href="#cb86-276" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-035}</span></span>
<span id="cb86-277"><a href="#cb86-277" aria-hidden="true" tabindex="-1"></a><span class="in">#| layout-ncol: 2</span></span>
<span id="cb86-278"><a href="#cb86-278" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-resamp-viz</span></span>
<span id="cb86-279"><a href="#cb86-279" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-subcap:</span></span>
<span id="cb86-280"><a href="#cb86-280" aria-hidden="true" tabindex="-1"></a><span class="in">#|   - "Boxplot of accuracy scores."</span></span>
<span id="cb86-281"><a href="#cb86-281" aria-hidden="true" tabindex="-1"></a><span class="in">#|   - "Histogram of accuracy scores."</span></span>
<span id="cb86-282"><a href="#cb86-282" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Boxplot and Histogram of accuracy scores."</span></span>
<span id="cb86-283"><a href="#cb86-283" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb86-284"><a href="#cb86-284" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "Left: a boxplot ranging from 0.875 to 1.0 and the interquartile range between 0.925 and 0.7. Right: a histogram with five bars in a roughly normal distribution with mean 0.95, minimum 0.875 and maximum 1.0."</span></span>
<span id="cb86-285"><a href="#cb86-285" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-286"><a href="#cb86-286" aria-hidden="true" tabindex="-1"></a><span class="in">rr = resample(tsk_penguins, lrn_rpart, rsmp("cv", folds = 10))</span></span>
<span id="cb86-287"><a href="#cb86-287" aria-hidden="true" tabindex="-1"></a><span class="in">plt1 = autoplot(rr, measure = msr("classif.acc"), type = "boxplot")</span></span>
<span id="cb86-288"><a href="#cb86-288" aria-hidden="true" tabindex="-1"></a><span class="in">plt1$layers[[1]]$aes_params$fill = "white"</span></span>
<span id="cb86-289"><a href="#cb86-289" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt1)</span></span>
<span id="cb86-290"><a href="#cb86-290" aria-hidden="true" tabindex="-1"></a><span class="in">plt2 = autoplot(rr, measure = msr("classif.acc"), type = "histogram")</span></span>
<span id="cb86-291"><a href="#cb86-291" aria-hidden="true" tabindex="-1"></a><span class="in">plt2$layers[[1]]$aes_params$fill = "white"</span></span>
<span id="cb86-292"><a href="#cb86-292" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt2)</span></span>
<span id="cb86-293"><a href="#cb86-293" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-294"><a href="#cb86-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-295"><a href="#cb86-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-296"><a href="#cb86-296" aria-hidden="true" tabindex="-1"></a><span class="fu">### ResampleResult Objects {#sec-resampling-inspect}</span></span>
<span id="cb86-297"><a href="#cb86-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-298"><a href="#cb86-298" aria-hidden="true" tabindex="-1"></a>As well as being useful for estimating the generalization performance, the <span class="in">`r ref("ResampleResult")`</span> object can also be used for model inspection.</span>
<span id="cb86-299"><a href="#cb86-299" aria-hidden="true" tabindex="-1"></a>We can use the <span class="in">`$predictions()`</span> method to obtain a list of <span class="in">`r ref("Prediction")`</span> objects corresponding to the predictions from each resampling iteration.</span>
<span id="cb86-300"><a href="#cb86-300" aria-hidden="true" tabindex="-1"></a>This can be used to analyze the predictions of individual intermediate models from each resampling iteration.</span>
<span id="cb86-301"><a href="#cb86-301" aria-hidden="true" tabindex="-1"></a>To understand the class better, we use it here to manually compute a macro averaged performance estimate.</span>
<span id="cb86-302"><a href="#cb86-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-303"><a href="#cb86-303" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-018}</span></span>
<span id="cb86-304"><a href="#cb86-304" aria-hidden="true" tabindex="-1"></a><span class="in"># list of prediction objects</span></span>
<span id="cb86-305"><a href="#cb86-305" aria-hidden="true" tabindex="-1"></a><span class="in">rrp = rr$predictions()</span></span>
<span id="cb86-306"><a href="#cb86-306" aria-hidden="true" tabindex="-1"></a><span class="in"># print first two</span></span>
<span id="cb86-307"><a href="#cb86-307" aria-hidden="true" tabindex="-1"></a><span class="in">rrp[1:2]</span></span>
<span id="cb86-308"><a href="#cb86-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-309"><a href="#cb86-309" aria-hidden="true" tabindex="-1"></a><span class="in"># macro averaged performance</span></span>
<span id="cb86-310"><a href="#cb86-310" aria-hidden="true" tabindex="-1"></a><span class="in">mean(sapply(rrp, function(.x) .x$score()))</span></span>
<span id="cb86-311"><a href="#cb86-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-312"><a href="#cb86-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-313"><a href="#cb86-313" aria-hidden="true" tabindex="-1"></a>The <span class="in">`$prediction()`</span> method can be used to extract a single <span class="in">`Prediction`</span> object that combines the predictions of each intermediate model across all resampling iterations.</span>
<span id="cb86-314"><a href="#cb86-314" aria-hidden="true" tabindex="-1"></a>The combined prediction object can, for example, be used to manually compute a micro-averaged performance estimate (see @sec-resampling-exec for how to you can micro-average more conveniently).</span>
<span id="cb86-315"><a href="#cb86-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-316"><a href="#cb86-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-319"><a href="#cb86-319" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-320"><a href="#cb86-320" aria-hidden="true" tabindex="-1"></a>prediction <span class="ot">=</span> rr<span class="sc">$</span><span class="fu">prediction</span>()</span>
<span id="cb86-321"><a href="#cb86-321" aria-hidden="true" tabindex="-1"></a>prediction</span>
<span id="cb86-322"><a href="#cb86-322" aria-hidden="true" tabindex="-1"></a>prediction<span class="sc">$</span><span class="fu">score</span>()</span>
<span id="cb86-323"><a href="#cb86-323" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-324"><a href="#cb86-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-325"><a href="#cb86-325" aria-hidden="true" tabindex="-1"></a>By default, the intermediate models produced at each resampling iteration are discarded after the prediction step to reduce memory consumption of the <span class="in">`ResampleResult`</span> object (only the predictions are required to calculate most performance measures).</span>
<span id="cb86-326"><a href="#cb86-326" aria-hidden="true" tabindex="-1"></a>However, it can sometimes be useful to inspect, compare, or extract information from these intermediate models.</span>
<span id="cb86-327"><a href="#cb86-327" aria-hidden="true" tabindex="-1"></a>We can configure the <span class="in">`r ref("resample()")`</span> function to keep the fitted intermediate models by setting <span class="in">`store_models = TRUE`</span>.</span>
<span id="cb86-328"><a href="#cb86-328" aria-hidden="true" tabindex="-1"></a>Each model trained in a specific resampling iteration can then be accessed via <span class="in">`$learners[[i]]$model`</span>, where <span class="in">`i`</span> refers to the <span class="in">`i`</span>-th resampling iteration:</span>
<span id="cb86-329"><a href="#cb86-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-330"><a href="#cb86-330" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-021}</span></span>
<span id="cb86-331"><a href="#cb86-331" aria-hidden="true" tabindex="-1"></a><span class="in">rr = resample(tsk_penguins, lrn_rpart, cv3, store_models = TRUE)</span></span>
<span id="cb86-332"><a href="#cb86-332" aria-hidden="true" tabindex="-1"></a><span class="in"># get the model from the first iteration</span></span>
<span id="cb86-333"><a href="#cb86-333" aria-hidden="true" tabindex="-1"></a><span class="in">rr$learners[[1]]$model</span></span>
<span id="cb86-334"><a href="#cb86-334" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-335"><a href="#cb86-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-336"><a href="#cb86-336" aria-hidden="true" tabindex="-1"></a>In this example, we could then inspect the most important variables in each iteration to help us learn more about the respective fitted models:</span>
<span id="cb86-337"><a href="#cb86-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-338"><a href="#cb86-338" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-022}</span></span>
<span id="cb86-339"><a href="#cb86-339" aria-hidden="true" tabindex="-1"></a><span class="in"># print 2nd and 3rd iteration</span></span>
<span id="cb86-340"><a href="#cb86-340" aria-hidden="true" tabindex="-1"></a><span class="in">lapply(rr$learners[2:3], function(x) x$model$variable.importance)</span></span>
<span id="cb86-341"><a href="#cb86-341" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-342"><a href="#cb86-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-343"><a href="#cb86-343" aria-hidden="true" tabindex="-1"></a><span class="fu">### Custom Resampling {#sec-resamp-custom}</span></span>
<span id="cb86-344"><a href="#cb86-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-345"><a href="#cb86-345" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb86-346"><a href="#cb86-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-347"><a href="#cb86-347" aria-hidden="true" tabindex="-1"></a>Sometimes it is necessary to perform resampling with custom splits, e.g., to reproduce results reported in a study with pre-defined folds.</span>
<span id="cb86-348"><a href="#cb86-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-349"><a href="#cb86-349" aria-hidden="true" tabindex="-1"></a>A custom holdout resampling strategy can be constructed using <span class="in">`rsmp("custom")`</span>, where the row IDs of the observations used for training and testing must be defined manually when instantiated with a task.</span>
<span id="cb86-350"><a href="#cb86-350" aria-hidden="true" tabindex="-1"></a>In the example below, we first construct a custom holdout resampling strategy by manually assigning row IDs to the <span class="in">`$train`</span> and <span class="in">`$test`</span> fields, then construct a resampling strategy with two iterations by passing row IDs as list elements:</span>
<span id="cb86-351"><a href="#cb86-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-352"><a href="#cb86-352" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-023}</span></span>
<span id="cb86-353"><a href="#cb86-353" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_custom = rsmp("custom")</span></span>
<span id="cb86-354"><a href="#cb86-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-355"><a href="#cb86-355" aria-hidden="true" tabindex="-1"></a><span class="in"># resampling strategy with two iterations</span></span>
<span id="cb86-356"><a href="#cb86-356" aria-hidden="true" tabindex="-1"></a><span class="in">train_sets = c(1:5, 153:158, 277:280)</span></span>
<span id="cb86-357"><a href="#cb86-357" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_custom$instantiate(tsk_penguins,</span></span>
<span id="cb86-358"><a href="#cb86-358" aria-hidden="true" tabindex="-1"></a><span class="in">  train = list(train_sets, train_sets + 5),</span></span>
<span id="cb86-359"><a href="#cb86-359" aria-hidden="true" tabindex="-1"></a><span class="in">  test = list(train_sets + 15, train_sets + 25)</span></span>
<span id="cb86-360"><a href="#cb86-360" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-361"><a href="#cb86-361" aria-hidden="true" tabindex="-1"></a><span class="in">resample(tsk_penguins, lrn_rpart, rsmp_custom)$prediction()</span></span>
<span id="cb86-362"><a href="#cb86-362" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-363"><a href="#cb86-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-364"><a href="#cb86-364" aria-hidden="true" tabindex="-1"></a>A custom cross-validation strategy can be more efficiently constructed with <span class="in">`rsmp("custom_cv")`</span>.</span>
<span id="cb86-365"><a href="#cb86-365" aria-hidden="true" tabindex="-1"></a>In this case, we now have to specify either a custom <span class="in">`factor`</span> variable or a <span class="in">`factor`</span> column from the data to determine the folds.</span>
<span id="cb86-366"><a href="#cb86-366" aria-hidden="true" tabindex="-1"></a>In the example below, we use a smaller version of <span class="in">`tsk("penguins")`</span> and instantiate a custom two-fold CV strategy using a <span class="in">`factor`</span> variable called <span class="in">`folds`</span> where the first and third rows are used as the test set in Fold 1, and the second and fourth rows are used as the test set in Fold 2:</span>
<span id="cb86-367"><a href="#cb86-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-368"><a href="#cb86-368" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-025}</span></span>
<span id="cb86-369"><a href="#cb86-369" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_small = tsk("penguins")$filter(c(1, 100, 200, 300))</span></span>
<span id="cb86-370"><a href="#cb86-370" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_customcv = rsmp("custom_cv")</span></span>
<span id="cb86-371"><a href="#cb86-371" aria-hidden="true" tabindex="-1"></a><span class="in">folds = as.factor(c(1, 2, 1, 2))</span></span>
<span id="cb86-372"><a href="#cb86-372" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_customcv$instantiate(tsk_small, f = folds)</span></span>
<span id="cb86-373"><a href="#cb86-373" aria-hidden="true" tabindex="-1"></a><span class="in">resample(tsk_small, lrn_rpart, rsmp_customcv)$predictions()</span></span>
<span id="cb86-374"><a href="#cb86-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-375"><a href="#cb86-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-376"><a href="#cb86-376" aria-hidden="true" tabindex="-1"></a><span class="fu">### Stratification and Grouping {#sec-strat-group}</span></span>
<span id="cb86-377"><a href="#cb86-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-378"><a href="#cb86-378" aria-hidden="true" tabindex="-1"></a>{{&lt; include ../../common/_optional.qmd &gt;}}</span>
<span id="cb86-379"><a href="#cb86-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-380"><a href="#cb86-380" aria-hidden="true" tabindex="-1"></a>Using column roles (@sec-row-col-roles), it is possible to group or stratify observations according to a particular column in the data.</span>
<span id="cb86-381"><a href="#cb86-381" aria-hidden="true" tabindex="-1"></a>We will look at each of these in turn.</span>
<span id="cb86-382"><a href="#cb86-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-383"><a href="#cb86-383" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `r index('Grouped Resampling')` {.unlisted .unnumbered}</span></span>
<span id="cb86-384"><a href="#cb86-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-385"><a href="#cb86-385" aria-hidden="true" tabindex="-1"></a>Keeping observations together when the data is split can be useful, and sometimes essential, during resampling -- spatial analysis (@sec-spatiotemporal) is a prominent example, as observations belong to natural groups (e.g., countries).</span>
<span id="cb86-386"><a href="#cb86-386" aria-hidden="true" tabindex="-1"></a>When observations belong to groups, we need to ensure all observations of the same group belong to *either* the training set *or* the test set to prevent potential leakage of information between training and testing.</span>
<span id="cb86-387"><a href="#cb86-387" aria-hidden="true" tabindex="-1"></a>For example, in a longitudinal study, measurements are taken from the same individual at multiple time points.</span>
<span id="cb86-388"><a href="#cb86-388" aria-hidden="true" tabindex="-1"></a>If we do not group these, we might overestimate the model's generalization capability to unseen individuals, because observations of the same individuals might simultaneously be in the train and test set.</span>
<span id="cb86-389"><a href="#cb86-389" aria-hidden="true" tabindex="-1"></a>In this context, the leave-one-out cross-validation strategy can be coarsened to the "leave-one-object-out" cross-validation strategy, where all observations associated with a certain group are left out (@fig-group).</span>
<span id="cb86-390"><a href="#cb86-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-391"><a href="#cb86-391" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-026, echo=FALSE}</span></span>
<span id="cb86-392"><a href="#cb86-392" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-group</span></span>
<span id="cb86-393"><a href="#cb86-393" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustration of the train-test splits of a leave-one-object-out cross-validation with 3 groups of observations (highlighted by different colors)."</span></span>
<span id="cb86-394"><a href="#cb86-394" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "Three images, each shows a green box with text 'Train' and white space around it with text 'Test'. Left (Iteration 1): green box with blue and red dots inside it and yellow dots outside it. Middle (Iteration 2): green box with blue and yellow dots inside it and red dots outside it. Right (Iteration 3): green box with yellow and red dots inside it and blue dots outside it."</span></span>
<span id="cb86-395"><a href="#cb86-395" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-7")</span></span>
<span id="cb86-396"><a href="#cb86-396" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-397"><a href="#cb86-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-398"><a href="#cb86-398" aria-hidden="true" tabindex="-1"></a>The <span class="in">`"group"`</span> column role allows us to specify the column in the data that defines the group structure of the observations.</span>
<span id="cb86-399"><a href="#cb86-399" aria-hidden="true" tabindex="-1"></a>In the following code, we construct a leave-one-out resampling strategy, assign the <span class="in">`"group"`</span> role to the 'year' column of <span class="in">`tsk("penguins")`</span>, instantiate the resampling strategy, and finally show how the years are nicely separated in the first fold.</span>
<span id="cb86-400"><a href="#cb86-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-401"><a href="#cb86-401" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-027}</span></span>
<span id="cb86-402"><a href="#cb86-402" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_loo = rsmp("loo")</span></span>
<span id="cb86-403"><a href="#cb86-403" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_grp = tsk("penguins")</span></span>
<span id="cb86-404"><a href="#cb86-404" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_grp$set_col_roles("year", "group")</span></span>
<span id="cb86-405"><a href="#cb86-405" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_loo$instantiate(tsk_grp)</span></span>
<span id="cb86-406"><a href="#cb86-406" aria-hidden="true" tabindex="-1"></a><span class="in">table(tsk_grp$data(rows = rsmp_loo$train_set(1), cols = "year"))</span></span>
<span id="cb86-407"><a href="#cb86-407" aria-hidden="true" tabindex="-1"></a><span class="in">table(tsk_grp$data(rows = rsmp_loo$test_set(1), cols = "year"))</span></span>
<span id="cb86-408"><a href="#cb86-408" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-409"><a href="#cb86-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-410"><a href="#cb86-410" aria-hidden="true" tabindex="-1"></a>Other cross-validation techniques work in a similar way, where folds are determined at a group level (as opposed to an observation level).</span>
<span id="cb86-411"><a href="#cb86-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-412"><a href="#cb86-412" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `r index('Stratified Sampling')` {.unlisted .unnumbered}</span></span>
<span id="cb86-413"><a href="#cb86-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-414"><a href="#cb86-414" aria-hidden="true" tabindex="-1"></a>Stratified sampling ensures that one or more discrete features within the training and test sets will have a similar distribution as in the original task containing all observations.</span>
<span id="cb86-415"><a href="#cb86-415" aria-hidden="true" tabindex="-1"></a>This is especially useful when a discrete feature is highly imbalanced and we want to make sure that the distribution of that feature is similar in each resampling iteration (@fig-stratification).</span>
<span id="cb86-416"><a href="#cb86-416" aria-hidden="true" tabindex="-1"></a>We can also stratify on the target feature to ensure that each intermediate model is fit on training data where the class distribution of the target is representative of the actual task, this is useful to ensure target classes are not strongly under-represented by random chance in individual resampling iterations, which would lead to degenerate estimations of the generalization performance.</span>
<span id="cb86-417"><a href="#cb86-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-418"><a href="#cb86-418" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-028, echo=FALSE}</span></span>
<span id="cb86-419"><a href="#cb86-419" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-stratification</span></span>
<span id="cb86-420"><a href="#cb86-420" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustration of a three-fold cross-validation with stratification for an imbalanced binary classification task with a majority class that is about twice as large as the minority class. In each resampling iteration, the class distribution from the available data is preserved (which is not necessarily the case for cross-validation without stratification)."</span></span>
<span id="cb86-421"><a href="#cb86-421" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "The figure shows rectangles in yellow and green to represent the majority and minority class respectively. On the left side are rectangles corresponding to the task before it is split; the majority class (yellow) on the left is clearly larger than the minority class (green) on the right. This is labeled 'Imabalanced Class Distribution'. In the next three boxes, labeled 'Iteration 1-3' respectively, the size difference between the majority and minority classes is preserved, i.e., the difference in size between majority and minority classes are equal."</span></span>
<span id="cb86-422"><a href="#cb86-422" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("mlr3book_figures-8")</span></span>
<span id="cb86-423"><a href="#cb86-423" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-424"><a href="#cb86-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-425"><a href="#cb86-425" aria-hidden="true" tabindex="-1"></a>Unlike grouping, it is possible to stratify by multiple discrete features using the <span class="in">`"stratum"`</span> column role (@sec-row-col-roles).</span>
<span id="cb86-426"><a href="#cb86-426" aria-hidden="true" tabindex="-1"></a>In this case, strata would be formed out of each combination of the stratified features, e.g., for two stratified features A and B with levels Aa, Ab; Ba, Bb respectively then the created stratum would have the levels AaBa, AaBb, AbBa, AbBb.</span>
<span id="cb86-427"><a href="#cb86-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-428"><a href="#cb86-428" aria-hidden="true" tabindex="-1"></a><span class="in">`tsk("penguins")`</span> displays imbalance in the <span class="in">`species`</span> column, as can be seen in the output below:</span>
<span id="cb86-429"><a href="#cb86-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-430"><a href="#cb86-430" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-029}</span></span>
<span id="cb86-431"><a href="#cb86-431" aria-hidden="true" tabindex="-1"></a><span class="in">prop.table(table(tsk_penguins$data(cols = "species")))</span></span>
<span id="cb86-432"><a href="#cb86-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-433"><a href="#cb86-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-434"><a href="#cb86-434" aria-hidden="true" tabindex="-1"></a>Without specifying a <span class="in">`"stratum"`</span> column role, the <span class="in">`species`</span> column may have quite different class distributions across the CV folds, as can be seen in the example below.</span>
<span id="cb86-435"><a href="#cb86-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-436"><a href="#cb86-436" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-030}</span></span>
<span id="cb86-437"><a href="#cb86-437" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_cv10 = rsmp("cv", folds = 10)</span></span>
<span id="cb86-438"><a href="#cb86-438" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_cv10$instantiate(tsk_penguins)</span></span>
<span id="cb86-439"><a href="#cb86-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-440"><a href="#cb86-440" aria-hidden="true" tabindex="-1"></a><span class="in">fold1 = prop.table(table(tsk_penguins$data(rows = rsmp_cv10$test_set(1),</span></span>
<span id="cb86-441"><a href="#cb86-441" aria-hidden="true" tabindex="-1"></a><span class="in">  cols = "species")))</span></span>
<span id="cb86-442"><a href="#cb86-442" aria-hidden="true" tabindex="-1"></a><span class="in">fold2 = prop.table(table(tsk_penguins$data(rows = rsmp_cv10$test_set(2),</span></span>
<span id="cb86-443"><a href="#cb86-443" aria-hidden="true" tabindex="-1"></a><span class="in">  cols = "species")))</span></span>
<span id="cb86-444"><a href="#cb86-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-445"><a href="#cb86-445" aria-hidden="true" tabindex="-1"></a><span class="in">rbind("Fold 1" = fold1, "Fold 2" = fold2)</span></span>
<span id="cb86-446"><a href="#cb86-446" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-447"><a href="#cb86-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-448"><a href="#cb86-448" aria-hidden="true" tabindex="-1"></a>We can see across folds how Chinstrap is represented quite differently (<span class="in">`r round(prop.table(table(tsk_penguins$data(rows = rsmp_cv10$test_set(1), cols = "species")))[2],2)`</span> vs. <span class="in">`r round(prop.table(table(tsk_penguins$data(rows = rsmp_cv10$test_set(2), cols = "species")))[2],2)`</span>)</span>
<span id="cb86-449"><a href="#cb86-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-450"><a href="#cb86-450" aria-hidden="true" tabindex="-1"></a>When imbalance is severe, minority classes might not occur in the training sets entirely.</span>
<span id="cb86-451"><a href="#cb86-451" aria-hidden="true" tabindex="-1"></a>Consequently, the intermediate models within these resampling iterations will never predict the missing class, resulting in a misleading performance estimate for any resampling strategy without stratification.</span>
<span id="cb86-452"><a href="#cb86-452" aria-hidden="true" tabindex="-1"></a>The code below uses <span class="in">`species`</span> as <span class="in">`"stratum"`</span> column role to illustrate that the distribution of <span class="in">`species`</span> in each test set will closely match the original distribution:</span>
<span id="cb86-453"><a href="#cb86-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-454"><a href="#cb86-454" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-031}</span></span>
<span id="cb86-455"><a href="#cb86-455" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_str = tsk("penguins")</span></span>
<span id="cb86-456"><a href="#cb86-456" aria-hidden="true" tabindex="-1"></a><span class="in"># set species to have both the 'target' and 'stratum' column role</span></span>
<span id="cb86-457"><a href="#cb86-457" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_str$set_col_roles("species", c("target", "stratum"))</span></span>
<span id="cb86-458"><a href="#cb86-458" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_cv10$instantiate(tsk_str)</span></span>
<span id="cb86-459"><a href="#cb86-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-460"><a href="#cb86-460" aria-hidden="true" tabindex="-1"></a><span class="in">fold1 = prop.table(table(tsk_str$data(rows = rsmp_cv10$test_set(1),</span></span>
<span id="cb86-461"><a href="#cb86-461" aria-hidden="true" tabindex="-1"></a><span class="in">  cols = "species")))</span></span>
<span id="cb86-462"><a href="#cb86-462" aria-hidden="true" tabindex="-1"></a><span class="in">fold2 = prop.table(table(tsk_str$data(rows = rsmp_cv10$test_set(2),</span></span>
<span id="cb86-463"><a href="#cb86-463" aria-hidden="true" tabindex="-1"></a><span class="in">  cols = "species")))</span></span>
<span id="cb86-464"><a href="#cb86-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-465"><a href="#cb86-465" aria-hidden="true" tabindex="-1"></a><span class="in">rbind("Fold 1" = fold1, "Fold 2" = fold2)</span></span>
<span id="cb86-466"><a href="#cb86-466" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-467"><a href="#cb86-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-468"><a href="#cb86-468" aria-hidden="true" tabindex="-1"></a>You can view the observations that fall into each stratum using the <span class="in">`$strata`</span> field of a <span class="in">`Task`</span> object, this can be particularly useful when we are interested in multiple strata:</span>
<span id="cb86-469"><a href="#cb86-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-470"><a href="#cb86-470" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-034}</span></span>
<span id="cb86-471"><a href="#cb86-471" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_str$set_col_roles("year", "stratum")</span></span>
<span id="cb86-472"><a href="#cb86-472" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_str$strata</span></span>
<span id="cb86-473"><a href="#cb86-473" aria-hidden="true" tabindex="-1"></a><span class="in"># N above matches with numbers in table below</span></span>
<span id="cb86-474"><a href="#cb86-474" aria-hidden="true" tabindex="-1"></a><span class="in">table(tsk_penguins$data(cols = c("species", "year")))</span></span>
<span id="cb86-475"><a href="#cb86-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-476"><a href="#cb86-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-477"><a href="#cb86-477" aria-hidden="true" tabindex="-1"></a><span class="fu">## Benchmarking {#sec-benchmarking}</span></span>
<span id="cb86-478"><a href="#cb86-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-479"><a href="#cb86-479" aria-hidden="true" tabindex="-1"></a>Benchmarking in supervised machine learning refers to the comparison of different learners on one or more tasks.</span>
<span id="cb86-480"><a href="#cb86-480" aria-hidden="true" tabindex="-1"></a>When comparing *multiple learners on a single task* or on a domain consisting of multiple similar tasks, the main aim is often to rank the learners according to a pre-defined performance measure and to identify the best-performing learner for the considered task or domain.</span>
<span id="cb86-481"><a href="#cb86-481" aria-hidden="true" tabindex="-1"></a>When comparing *multiple learners on multiple tasks*, the main aim is often more of a scientific nature, e.g., to gain insights into how different learners perform in different data situations or whether there are certain data properties that heavily affect the performance of certain learners (or certain hyperparameters of learners).</span>
<span id="cb86-482"><a href="#cb86-482" aria-hidden="true" tabindex="-1"></a>It is common (and good) practice for algorithm designers to analyze the generalization performance or runtime of a newly proposed learning algorithm in comparison to existing learners in a <span class="in">`r index("benchmark experiment")`</span>.</span>
<span id="cb86-483"><a href="#cb86-483" aria-hidden="true" tabindex="-1"></a>Since benchmarks usually consist of many evaluations that can be run independently of each other, <span class="in">`mlr3`</span> offers the possibility of parallelizing them automatically, which we demonstrate in @sec-parallel-resample.</span>
<span id="cb86-484"><a href="#cb86-484" aria-hidden="true" tabindex="-1"></a>In this section, we will focus on the basic setup of benchmark experiments that will be applicable in the majority of use cases, in @sec-large-benchmarking we will look at more complex, large-scale, benchmark experiments.</span>
<span id="cb86-485"><a href="#cb86-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-486"><a href="#cb86-486" aria-hidden="true" tabindex="-1"></a><span class="fu">### benchmark() {#sec-bm-design}</span></span>
<span id="cb86-487"><a href="#cb86-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-488"><a href="#cb86-488" aria-hidden="true" tabindex="-1"></a><span class="in">`r index('Benchmark experiments')`</span> in <span class="in">`mlr3`</span> are conducted with <span class="in">`r ref("benchmark()", index = TRUE)`</span>, which simply runs <span class="in">`r ref("resample()", index = TRUE)`</span> on each task and learner separately, then collects the results.</span>
<span id="cb86-489"><a href="#cb86-489" aria-hidden="true" tabindex="-1"></a>The provided resampling strategy is automatically instantiated on each task to ensure that all learners are compared against the same training and test data.</span>
<span id="cb86-490"><a href="#cb86-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-491"><a href="#cb86-491" aria-hidden="true" tabindex="-1"></a>To use the <span class="in">`benchmark()`</span> function we first call <span class="in">`r ref("benchmark_grid()")`</span>, which constructs an exhaustive *design* to describe all combinations of the learners, tasks and resamplings to be used in a benchmark experiment, and instantiates the resampling strategies.</span>
<span id="cb86-492"><a href="#cb86-492" aria-hidden="true" tabindex="-1"></a>By example, below we set up a design to see if a random forest, decision tree, or featureless baseline (@sec-basics-featureless), performs best across two classification tasks.</span>
<span id="cb86-493"><a href="#cb86-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-494"><a href="#cb86-494" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-037}</span></span>
<span id="cb86-495"><a href="#cb86-495" aria-hidden="true" tabindex="-1"></a><span class="in">tasks = tsks(c("german_credit", "sonar"))</span></span>
<span id="cb86-496"><a href="#cb86-496" aria-hidden="true" tabindex="-1"></a><span class="in">learners = lrns(c("classif.rpart", "classif.ranger",</span></span>
<span id="cb86-497"><a href="#cb86-497" aria-hidden="true" tabindex="-1"></a><span class="in">  "classif.featureless"), predict_type = "prob")</span></span>
<span id="cb86-498"><a href="#cb86-498" aria-hidden="true" tabindex="-1"></a><span class="in">rsmp_cv5 = rsmp("cv", folds = 5)</span></span>
<span id="cb86-499"><a href="#cb86-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-500"><a href="#cb86-500" aria-hidden="true" tabindex="-1"></a><span class="in">design = benchmark_grid(tasks, learners, rsmp_cv5)</span></span>
<span id="cb86-501"><a href="#cb86-501" aria-hidden="true" tabindex="-1"></a><span class="in">head(design)</span></span>
<span id="cb86-502"><a href="#cb86-502" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-503"><a href="#cb86-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-504"><a href="#cb86-504" aria-hidden="true" tabindex="-1"></a>The resulting design is essentially just a <span class="in">`data.table`</span>, which can be modified if you want to remove particular combinations or could even be created from scratch without the <span class="in">`benchmark_grid()`</span> function.</span>
<span id="cb86-505"><a href="#cb86-505" aria-hidden="true" tabindex="-1"></a>Note that this <span class="in">`data.table`</span> has list columns that contain R6 objects of tasks, learners, and resampling instances.</span>
<span id="cb86-506"><a href="#cb86-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-507"><a href="#cb86-507" aria-hidden="true" tabindex="-1"></a>::: {.callout-warning}</span>
<span id="cb86-508"><a href="#cb86-508" aria-hidden="true" tabindex="-1"></a><span class="fu">## Reproducibility When Using `benchmark_grid()`</span></span>
<span id="cb86-509"><a href="#cb86-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-510"><a href="#cb86-510" aria-hidden="true" tabindex="-1"></a>By default, <span class="in">`r ref("benchmark_grid()")`</span> instantiates the resamplings on the tasks, which means that concrete train-test splits are generated.</span>
<span id="cb86-511"><a href="#cb86-511" aria-hidden="true" tabindex="-1"></a>Since this process is stochastic, it is necessary to set a seed **before** calling <span class="in">`benchmark_grid()`</span> to ensure reproducibility of the data splits.</span>
<span id="cb86-512"><a href="#cb86-512" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-513"><a href="#cb86-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-514"><a href="#cb86-514" aria-hidden="true" tabindex="-1"></a>The constructed benchmark design can then be passed to <span class="in">`benchmark()`</span> to run the experiment and the result is a <span class="in">`r ref("BenchmarkResult")`</span> object:</span>
<span id="cb86-515"><a href="#cb86-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-516"><a href="#cb86-516" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-039}</span></span>
<span id="cb86-517"><a href="#cb86-517" aria-hidden="true" tabindex="-1"></a><span class="in">bmr = benchmark(design)</span></span>
<span id="cb86-518"><a href="#cb86-518" aria-hidden="true" tabindex="-1"></a><span class="in">bmr</span></span>
<span id="cb86-519"><a href="#cb86-519" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-520"><a href="#cb86-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-521"><a href="#cb86-521" aria-hidden="true" tabindex="-1"></a>As <span class="in">`benchmark()`</span> is just an extension of <span class="in">`resample()`</span>, we can once again use <span class="in">`$score()`</span>, or <span class="in">`$aggregate()`</span> depending on your use-case, though note that in this case <span class="in">`$score()`</span> will return results over each fold of each learner/task/resampling combination.</span>
<span id="cb86-522"><a href="#cb86-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-523"><a href="#cb86-523" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-040}</span></span>
<span id="cb86-524"><a href="#cb86-524" aria-hidden="true" tabindex="-1"></a><span class="in">bmr$score()[c(1, 7, 13), .(iteration, task_id, learner_id, classif.ce)]</span></span>
<span id="cb86-525"><a href="#cb86-525" aria-hidden="true" tabindex="-1"></a><span class="in">bmr$aggregate()[, .(task_id, learner_id, classif.ce)]</span></span>
<span id="cb86-526"><a href="#cb86-526" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-527"><a href="#cb86-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-528"><a href="#cb86-528" aria-hidden="true" tabindex="-1"></a>This would conclude a basic benchmark experiment where you can draw tentative conclusions about model performance, in this case we would possibly conclude that the random forest is the best of all three models on each task.</span>
<span id="cb86-529"><a href="#cb86-529" aria-hidden="true" tabindex="-1"></a>We draw conclusions cautiously here as we have not run any statistical tests or included standard errors of measures, so we cannot definitively say if one model outperforms the other.</span>
<span id="cb86-530"><a href="#cb86-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-531"><a href="#cb86-531" aria-hidden="true" tabindex="-1"></a>As the results of <span class="in">`$score()`</span> and <span class="in">`$aggregate()`</span> are returned in a <span class="in">`data.table`</span>, you can post-process and analyze the results in any way you want.</span>
<span id="cb86-532"><a href="#cb86-532" aria-hidden="true" tabindex="-1"></a>A common *mistake* is to average the learner performance across all tasks when the tasks vary significantly.</span>
<span id="cb86-533"><a href="#cb86-533" aria-hidden="true" tabindex="-1"></a>This is a mistake as averaging the performance will miss out important insights into how learners compare on 'easier' or more 'difficult' predictive problems.</span>
<span id="cb86-534"><a href="#cb86-534" aria-hidden="true" tabindex="-1"></a>A more robust alternative to compare the overall algorithm performance across multiple tasks is to compute the ranks of each learner on each task separately and then calculate the average ranks.</span>
<span id="cb86-535"><a href="#cb86-535" aria-hidden="true" tabindex="-1"></a>This can provide a better comparison as task-specific 'quirks' are taken into account by comparing learners within tasks before comparing them across tasks.</span>
<span id="cb86-536"><a href="#cb86-536" aria-hidden="true" tabindex="-1"></a>However, using ranks will lose information about the numerical differences between the calculated performance scores.</span>
<span id="cb86-537"><a href="#cb86-537" aria-hidden="true" tabindex="-1"></a>Analysis of benchmark experiments, including statistical tests, is covered in more detail in @sec-benchmark-analysis.</span>
<span id="cb86-538"><a href="#cb86-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-539"><a href="#cb86-539" aria-hidden="true" tabindex="-1"></a><span class="fu">### BenchmarkResult Objects {#sec-bm-resamp}</span></span>
<span id="cb86-540"><a href="#cb86-540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-541"><a href="#cb86-541" aria-hidden="true" tabindex="-1"></a>A <span class="in">`r ref("BenchmarkResult")`</span> object is a collection of multiple <span class="in">`r ref("ResampleResult", index = TRUE)`</span> objects.</span>
<span id="cb86-542"><a href="#cb86-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-543"><a href="#cb86-543" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-043}</span></span>
<span id="cb86-544"><a href="#cb86-544" aria-hidden="true" tabindex="-1"></a><span class="in">bmrdt = as.data.table(bmr)</span></span>
<span id="cb86-545"><a href="#cb86-545" aria-hidden="true" tabindex="-1"></a><span class="in">bmrdt[1:2, .(task, learner, resampling, iteration)]</span></span>
<span id="cb86-546"><a href="#cb86-546" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-547"><a href="#cb86-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-548"><a href="#cb86-548" aria-hidden="true" tabindex="-1"></a>The contents of a <span class="in">`BenchmarkResult`</span> and <span class="in">`ResampleResult`</span> (@sec-resampling-inspect) are almost identical and the stored <span class="in">`ResampleResult`</span>s can be extracted via the <span class="in">`$resample_result(i)`</span> method, where <span class="in">`i`</span> is the index of the performed resample experiment.</span>
<span id="cb86-549"><a href="#cb86-549" aria-hidden="true" tabindex="-1"></a>This allows us to investigate the extracted <span class="in">`ResampleResult`</span> and individual resampling iterations as shown in @sec-resampling, as well as the predictions from each fold with <span class="in">`$resample_result(i)$predictions()`</span>.</span>
<span id="cb86-550"><a href="#cb86-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-551"><a href="#cb86-551" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-044}</span></span>
<span id="cb86-552"><a href="#cb86-552" aria-hidden="true" tabindex="-1"></a><span class="in">rr1 = bmr$resample_result(1)</span></span>
<span id="cb86-553"><a href="#cb86-553" aria-hidden="true" tabindex="-1"></a><span class="in">rr1</span></span>
<span id="cb86-554"><a href="#cb86-554" aria-hidden="true" tabindex="-1"></a><span class="in">rr2 = bmr$resample_result(2)</span></span>
<span id="cb86-555"><a href="#cb86-555" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-556"><a href="#cb86-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-557"><a href="#cb86-557" aria-hidden="true" tabindex="-1"></a>In addition, <span class="in">`r ref('as_benchmark_result()')`</span> can be used to convert objects from <span class="in">`ResampleResult`</span> to <span class="in">`BenchmarkResult`</span>.</span>
<span id="cb86-558"><a href="#cb86-558" aria-hidden="true" tabindex="-1"></a>The <span class="in">`c()`</span>-method can be used to combine multiple <span class="in">`BenchmarkResult`</span> objects, which can be useful when conducting experiments across multiple machines:</span>
<span id="cb86-559"><a href="#cb86-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-560"><a href="#cb86-560" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-045}</span></span>
<span id="cb86-561"><a href="#cb86-561" aria-hidden="true" tabindex="-1"></a><span class="in">bmr1 = as_benchmark_result(rr1)</span></span>
<span id="cb86-562"><a href="#cb86-562" aria-hidden="true" tabindex="-1"></a><span class="in">bmr2 = as_benchmark_result(rr2)</span></span>
<span id="cb86-563"><a href="#cb86-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-564"><a href="#cb86-564" aria-hidden="true" tabindex="-1"></a><span class="in">c(bmr1, bmr2)</span></span>
<span id="cb86-565"><a href="#cb86-565" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-566"><a href="#cb86-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-567"><a href="#cb86-567" aria-hidden="true" tabindex="-1"></a>Boxplots are most commonly used to visualize benchmark experiments as they can intuitively summarize results across tasks and learners simultaneously.</span>
<span id="cb86-568"><a href="#cb86-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-569"><a href="#cb86-569" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-046}</span></span>
<span id="cb86-570"><a href="#cb86-570" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb86-571"><a href="#cb86-571" aria-hidden="true" tabindex="-1"></a><span class="in">#| cache: false</span></span>
<span id="cb86-572"><a href="#cb86-572" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(bmr, measure = msr("classif.acc"))</span></span>
<span id="cb86-573"><a href="#cb86-573" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-574"><a href="#cb86-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-575"><a href="#cb86-575" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.width = "70%"}</span></span>
<span id="cb86-576"><a href="#cb86-576" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-height: 5</span></span>
<span id="cb86-577"><a href="#cb86-577" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-width: 6</span></span>
<span id="cb86-578"><a href="#cb86-578" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-benchmark-box</span></span>
<span id="cb86-579"><a href="#cb86-579" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: 'Boxplots of accuracy scores for each learner across resampling iterations and the three tasks. Random forests (`lrn("classif.ranger")`) consistently outperforms the other learners.'</span></span>
<span id="cb86-580"><a href="#cb86-580" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: Nine boxplots, one corresponding to each task/learner combination. In all cases the random forest performs best and the featureless baseline the worst.</span></span>
<span id="cb86-581"><a href="#cb86-581" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-582"><a href="#cb86-582" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb86-583"><a href="#cb86-583" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb86-584"><a href="#cb86-584" aria-hidden="true" tabindex="-1"></a><span class="in">plt = ggplot2::last_plot()</span></span>
<span id="cb86-585"><a href="#cb86-585" aria-hidden="true" tabindex="-1"></a><span class="in">plt = plt + ggplot2::scale_fill_manual(values = c("grey30", "grey50", "grey70"))</span></span>
<span id="cb86-586"><a href="#cb86-586" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt)</span></span>
<span id="cb86-587"><a href="#cb86-587" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-588"><a href="#cb86-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-589"><a href="#cb86-589" aria-hidden="true" tabindex="-1"></a><span class="fu">## Evaluation of Binary Classifiers {#sec-roc}</span></span>
<span id="cb86-590"><a href="#cb86-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-591"><a href="#cb86-591" aria-hidden="true" tabindex="-1"></a>In @sec-basics-classif-learner we touched on the concept of a confusion matrix and how it can be used to break down classification errors in more detail.</span>
<span id="cb86-592"><a href="#cb86-592" aria-hidden="true" tabindex="-1"></a>In this section, we will look at specialized performance measures for binary classification\index{classification!binary} in more detail.</span>
<span id="cb86-593"><a href="#cb86-593" aria-hidden="true" tabindex="-1"></a>We will first return to the confusion matrix and discuss measures that can be derived from it and then will look at <span class="in">`r index('ROC', lower = FALSE)`</span> analysis which builds on these measures.</span>
<span id="cb86-594"><a href="#cb86-594" aria-hidden="true" tabindex="-1"></a>See Chapters 7 and 8 of @provost2013 for a more detailed introduction to ROC measures.</span>
<span id="cb86-595"><a href="#cb86-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-596"><a href="#cb86-596" aria-hidden="true" tabindex="-1"></a><span class="fu">### Confusion Matrix</span></span>
<span id="cb86-597"><a href="#cb86-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-598"><a href="#cb86-598" aria-hidden="true" tabindex="-1"></a>To recap, a <span class="in">`r index('confusion matrix')`</span> summarizes the following quantities in a two-dimensional contingency table (see also @fig-confusion):</span>
<span id="cb86-599"><a href="#cb86-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-600"><a href="#cb86-600" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r index('True positives')`</span> (TPs): Positive instances that are correctly classified as positive.</span>
<span id="cb86-601"><a href="#cb86-601" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r index('True negatives')`</span> (TNs): Negative instances that are correctly classified as negative.</span>
<span id="cb86-602"><a href="#cb86-602" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r index('False positives')`</span> (FPs): Negative instances that are incorrectly classified as positive.</span>
<span id="cb86-603"><a href="#cb86-603" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span><span class="in">`r index('False negatives')`</span> (FNs): Positive instances that are incorrectly classified as negative.</span>
<span id="cb86-604"><a href="#cb86-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-605"><a href="#cb86-605" aria-hidden="true" tabindex="-1"></a>Different applications may have a particular interest in one (or multiple) of the aforementioned quantities.</span>
<span id="cb86-606"><a href="#cb86-606" aria-hidden="true" tabindex="-1"></a>For example, the <span class="in">`tsk("spam")`</span> classification task is concerned with classifying if mail is spam (positive class) or not (negative class).</span>
<span id="cb86-607"><a href="#cb86-607" aria-hidden="true" tabindex="-1"></a>In this case, we are likely to accept FNs (some spam classified as genuine mail) as long as we have a low number of FPs (genuine and possibly important mail classified as spam).</span>
<span id="cb86-608"><a href="#cb86-608" aria-hidden="true" tabindex="-1"></a>In another example, say we are predicting if a travel bag contains a weapon (positive class) or not (negative class) at an airport.</span>
<span id="cb86-609"><a href="#cb86-609" aria-hidden="true" tabindex="-1"></a>This classifier must have a very high number of TPs (as FNs are not acceptable at all), even if this comes at the expense of more FPs (false alarms).</span>
<span id="cb86-610"><a href="#cb86-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-611"><a href="#cb86-611" aria-hidden="true" tabindex="-1"></a>As we saw in @sec-basics-classif-learner, it is possible for a classifier to have a good classification accuracy but to overlook the nuances provided by a full confusion matrix, as in the following <span class="in">`tsk("german_credit")`</span> example:</span>
<span id="cb86-612"><a href="#cb86-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-613"><a href="#cb86-613" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-050}</span></span>
<span id="cb86-614"><a href="#cb86-614" aria-hidden="true" tabindex="-1"></a><span class="in">tsk_german = tsk("german_credit")</span></span>
<span id="cb86-615"><a href="#cb86-615" aria-hidden="true" tabindex="-1"></a><span class="in">lrn_ranger = lrn("classif.ranger", predict_type = "prob")</span></span>
<span id="cb86-616"><a href="#cb86-616" aria-hidden="true" tabindex="-1"></a><span class="in">splits = partition(tsk_german, ratio = 0.8)</span></span>
<span id="cb86-617"><a href="#cb86-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-618"><a href="#cb86-618" aria-hidden="true" tabindex="-1"></a><span class="in">lrn_ranger$train(tsk_german, splits$train)</span></span>
<span id="cb86-619"><a href="#cb86-619" aria-hidden="true" tabindex="-1"></a><span class="in">prediction = lrn_ranger$predict(tsk_german, splits$test)</span></span>
<span id="cb86-620"><a href="#cb86-620" aria-hidden="true" tabindex="-1"></a><span class="in">prediction$score(msr("classif.acc"))</span></span>
<span id="cb86-621"><a href="#cb86-621" aria-hidden="true" tabindex="-1"></a><span class="in">prediction$confusion</span></span>
<span id="cb86-622"><a href="#cb86-622" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-623"><a href="#cb86-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-624"><a href="#cb86-624" aria-hidden="true" tabindex="-1"></a>The classification accuracy only takes into account the TPs and TNs, whereas the confusion matrix provides a more holistic picture of the classifier's performance.</span>
<span id="cb86-625"><a href="#cb86-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-626"><a href="#cb86-626" aria-hidden="true" tabindex="-1"></a>On their own, the absolute numbers in a confusion matrix can be less useful when there is class imbalance.</span>
<span id="cb86-627"><a href="#cb86-627" aria-hidden="true" tabindex="-1"></a>Instead, several normalized measures can be derived (@fig-confusion):</span>
<span id="cb86-628"><a href="#cb86-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-629"><a href="#cb86-629" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**True Positive Rate\index{true positive rate}\index{sensitivity|see{measures, true positive rate}}\index{recall|see{measures, true positive rate}} (TPR)**, **Sensitivity** or **Recall**: How many of the true positives did we predict as positive?</span>
<span id="cb86-630"><a href="#cb86-630" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**True Negative Rate\index{true negative rate}\index{specificity|see{measures, true negative rate}} (TNR)** or **Specificity**: How many of the true negatives did we predict as negative?</span>
<span id="cb86-631"><a href="#cb86-631" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**False Positive Rate\index{false positive rate} (FPR)**, or $1 -$ **Specificity**: How many of the true negatives did we predict as positive?</span>
<span id="cb86-632"><a href="#cb86-632" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**Positive Predictive Value\index{positive predictive value}\index{precision|see{measures, positive predictive value}} (PPV)** or **Precision**: If we predict positive how likely is it a true positive?</span>
<span id="cb86-633"><a href="#cb86-633" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**Negative Predictive Value\index{negative predictive value} (NPV)**: If we predict negative how likely is it a true negative?</span>
<span id="cb86-634"><a href="#cb86-634" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**Accuracy (ACC)\index{accuracy}**: The proportion of correctly classified instances out of the total number of instances.</span>
<span id="cb86-635"><a href="#cb86-635" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>**F1-score\index{F1}**: The harmonic mean of precision and recall, which balances the trade-off between precision and recall. It is calculated as $2 \times \frac{Precision \times Recall}{Precision + Recall}$.</span>
<span id="cb86-636"><a href="#cb86-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-637"><a href="#cb86-637" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-049}</span></span>
<span id="cb86-638"><a href="#cb86-638" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-639"><a href="#cb86-639" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-confusion</span></span>
<span id="cb86-640"><a href="#cb86-640" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Binary confusion matrix of ground truth class vs. predicted class."</span></span>
<span id="cb86-641"><a href="#cb86-641" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "Representation of a confusion matrix with entries 'TP' when both 'True class y' is '+'' and 'Predicted Class yhat' is '+', 'TN' when both are '-', 'FP' when True is '-' and Predicted is '+' and finally 'FN' when True is '+' but Predicted is '-'. In the margins is 'PPV = TP/(TP+FP)', 'NPV = TN/(FN+TN)', 'ACC=(TP+TN)/(TP+FP+FN+TN)', 'TNR=TN/(FP+TN)', 'TPR=TP/(TP+FN)'."</span></span>
<span id="cb86-642"><a href="#cb86-642" aria-hidden="true" tabindex="-1"></a><span class="in">include_multi_graphics("confusion_matrix")</span></span>
<span id="cb86-643"><a href="#cb86-643" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-644"><a href="#cb86-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-645"><a href="#cb86-645" aria-hidden="true" tabindex="-1"></a>The <span class="in">`r ref_pkg("mlr3measures")`</span> package allows you to compute several common confusion matrix-based measures using the <span class="in">`r ref("mlr3measures::confusion_matrix()")`</span> function:</span>
<span id="cb86-646"><a href="#cb86-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-647"><a href="#cb86-647" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-051}</span></span>
<span id="cb86-648"><a href="#cb86-648" aria-hidden="true" tabindex="-1"></a><span class="in">mlr3measures::confusion_matrix(truth = prediction$truth,</span></span>
<span id="cb86-649"><a href="#cb86-649" aria-hidden="true" tabindex="-1"></a><span class="in">  response = prediction$response, positive = tsk_german$positive)</span></span>
<span id="cb86-650"><a href="#cb86-650" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-651"><a href="#cb86-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-652"><a href="#cb86-652" aria-hidden="true" tabindex="-1"></a>We now have a better idea of the random forest predictions on <span class="in">`tsk("german_credit")`</span>, in particular, the false positive rate is quite high.</span>
<span id="cb86-653"><a href="#cb86-653" aria-hidden="true" tabindex="-1"></a>It is generally difficult to achieve a high TPR and low FPR simultaneously because there is often a trade-off between the two rates.</span>
<span id="cb86-654"><a href="#cb86-654" aria-hidden="true" tabindex="-1"></a>When a binary classifier predicts probabilities instead of discrete classes (<span class="in">`predict_type = "prob"`</span>), we could set a threshold to cut off the probabilities to change how we assign observations to the positive/negative class (see @sec-classif-prediction).</span>
<span id="cb86-655"><a href="#cb86-655" aria-hidden="true" tabindex="-1"></a>Increasing the threshold for identifying the positive cases, leads to a higher number of negative predictions, fewer positive predictions, and therefore a lower (and better) FPR but a lower (and worse) TPR -- the reverse holds if we lower the threshold.</span>
<span id="cb86-656"><a href="#cb86-656" aria-hidden="true" tabindex="-1"></a>Instead of arbitrarily changing a threshold to 'game' these two numbers, a more robust way to tradeoff between TPR and FPR is to use ROC analysis, discussed next.</span>
<span id="cb86-657"><a href="#cb86-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-658"><a href="#cb86-658" aria-hidden="true" tabindex="-1"></a><span class="fu">### ROC Analysis {#sec-roc-space}</span></span>
<span id="cb86-659"><a href="#cb86-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-660"><a href="#cb86-660" aria-hidden="true" tabindex="-1"></a><span class="in">`r index('ROC', lower = FALSE)`</span> (Receiver Operating Characteristic) analysis is widely used to evaluate binary classifiers by visualizing the trade-off between the TPR and the FPR.</span>
<span id="cb86-661"><a href="#cb86-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-662"><a href="#cb86-662" aria-hidden="true" tabindex="-1"></a>The ROC curve is a line graph with TPR on the y-axis and the FPR on the x-axis.</span>
<span id="cb86-663"><a href="#cb86-663" aria-hidden="true" tabindex="-1"></a>To understand the usefulness of this curve, first consider the simple case of a hard labeling classifier (<span class="in">`predict_type = "response"`</span>) that classifies observations as either positive or negative.</span>
<span id="cb86-664"><a href="#cb86-664" aria-hidden="true" tabindex="-1"></a>This classifier would be represented as a single point in the ROC space (see @fig-roc, panel (a)).</span>
<span id="cb86-665"><a href="#cb86-665" aria-hidden="true" tabindex="-1"></a>The best classifier would lie on the top-left corner where the TPR is $1$ and the FPR is $0$.</span>
<span id="cb86-666"><a href="#cb86-666" aria-hidden="true" tabindex="-1"></a>Classifiers on the diagonal predict class labels randomly (with different class proportions).</span>
<span id="cb86-667"><a href="#cb86-667" aria-hidden="true" tabindex="-1"></a>For example, if each positive instance will be randomly classified (ignoring features) with 25% as the positive class, we would obtain a TPR of 0.25.</span>
<span id="cb86-668"><a href="#cb86-668" aria-hidden="true" tabindex="-1"></a>If we assign each negative instance randomly to the positive class, we would have an FPR of 0.25.</span>
<span id="cb86-669"><a href="#cb86-669" aria-hidden="true" tabindex="-1"></a>In practice, we should never obtain a classifier below the diagonal and a point in the ROC space below the diagonal might indicate that the positive and negative class labels have been switched by the classifier.</span>
<span id="cb86-670"><a href="#cb86-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-671"><a href="#cb86-671" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-054, echo = FALSE, fig.height = 3.5, fig.width = 8}</span></span>
<span id="cb86-672"><a href="#cb86-672" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-roc</span></span>
<span id="cb86-673"><a href="#cb86-673" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Panel (a): ROC space with best discrete classifier, two baseline classifiers -- one that always predicts the positive class and one that never predicts the positive class -- and three 'real' classifiers C1, C2, C3. We cannot say if C1 or C3 is better than the other as both are better in one metric. C2 is clearly worse than C1 and C3, which are better in at least one metric than C2 while not being worse in any other metric. Panel (b): ROC curves of the best classifier (AUC = 1), of a random guessing classifier (AUC = 0.5), and the classifiers C1, C3, and C2."</span></span>
<span id="cb86-674"><a href="#cb86-674" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: "Two plots labeled (a) and (b). Both have 'FPR' between 0-1 on x-axis and 'TPR' between 0-1 on y-axis, both also have a diagonal line y=x with text 'baseline (random classifiers)'. (a): There is a green dot in upper left corner at (0,1). There is a triangle labeled C1 at around (0.1,0.75), a square labeled C2 at around (0.24, 0.75), and a plus labeled C3 at around (0.25, 0.8). (b) is same as (a) except now there are three dashed lines such that each of the points from (a) lies on one of these lines. The lines roughly curve from (0,0) towards (0,1) and then to (1,1)"</span></span>
<span id="cb86-675"><a href="#cb86-675" aria-hidden="true" tabindex="-1"></a><span class="in">#library(gridExtra)</span></span>
<span id="cb86-676"><a href="#cb86-676" aria-hidden="true" tabindex="-1"></a><span class="in">library(ggplot2)</span></span>
<span id="cb86-677"><a href="#cb86-677" aria-hidden="true" tabindex="-1"></a><span class="in"># devtools::install_github("thomasp85/patchwork")</span></span>
<span id="cb86-678"><a href="#cb86-678" aria-hidden="true" tabindex="-1"></a><span class="in">library(patchwork)</span></span>
<span id="cb86-679"><a href="#cb86-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-680"><a href="#cb86-680" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(123)</span></span>
<span id="cb86-681"><a href="#cb86-681" aria-hidden="true" tabindex="-1"></a><span class="in">fun = function(x, lambda) 1 - exp(-lambda*x) #ecdf(rexp(1000000, rate = 5))</span></span>
<span id="cb86-682"><a href="#cb86-682" aria-hidden="true" tabindex="-1"></a><span class="in">funinv = function(x, lambda) 1 + log(x)/lambda</span></span>
<span id="cb86-683"><a href="#cb86-683" aria-hidden="true" tabindex="-1"></a><span class="in">x = c(seq(2e-5, 1, length = 1000))</span></span>
<span id="cb86-684"><a href="#cb86-684" aria-hidden="true" tabindex="-1"></a><span class="in">lambda1 =  -1*log(1 - 0.75)/0.125</span></span>
<span id="cb86-685"><a href="#cb86-685" aria-hidden="true" tabindex="-1"></a><span class="in">lambda2 =  -1*log(1 - 0.625)/0.25</span></span>
<span id="cb86-686"><a href="#cb86-686" aria-hidden="true" tabindex="-1"></a><span class="in">#lambda3 =  -1*log(1 - 0.875)/0.25</span></span>
<span id="cb86-687"><a href="#cb86-687" aria-hidden="true" tabindex="-1"></a><span class="in">d1 = data.frame(x = x, y = fun(x, lambda = lambda1))</span></span>
<span id="cb86-688"><a href="#cb86-688" aria-hidden="true" tabindex="-1"></a><span class="in">d2 = data.frame(x = x, y = fun(x, lambda = lambda2))</span></span>
<span id="cb86-689"><a href="#cb86-689" aria-hidden="true" tabindex="-1"></a><span class="in">d3 = data.frame(x = x, y = funinv(x, lambda = lambda1))#fun(x, lambda = lambda3))</span></span>
<span id="cb86-690"><a href="#cb86-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-691"><a href="#cb86-691" aria-hidden="true" tabindex="-1"></a><span class="in"># mean(d1$y)</span></span>
<span id="cb86-692"><a href="#cb86-692" aria-hidden="true" tabindex="-1"></a><span class="in"># mean(d2$y)</span></span>
<span id="cb86-693"><a href="#cb86-693" aria-hidden="true" tabindex="-1"></a><span class="in"># mean(d3$y)</span></span>
<span id="cb86-694"><a href="#cb86-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-695"><a href="#cb86-695" aria-hidden="true" tabindex="-1"></a><span class="in">rd = data.frame(x = c(0, 1), y = c(0, 1))</span></span>
<span id="cb86-696"><a href="#cb86-696" aria-hidden="true" tabindex="-1"></a><span class="in">classif = data.frame(x = c(0, 1, 1, 0, 0.125, 0.25, 0.25), y = c(1, 0, 1, 0, 0.75, 0.625, 0.875),</span></span>
<span id="cb86-697"><a href="#cb86-697" aria-hidden="true" tabindex="-1"></a><span class="in">  classifier = c("best", "worst", "baseline", "baseline", "C1", "C2", "C3"))</span></span>
<span id="cb86-698"><a href="#cb86-698" aria-hidden="true" tabindex="-1"></a><span class="in">classif = droplevels(classif[-2, ])</span></span>
<span id="cb86-699"><a href="#cb86-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-700"><a href="#cb86-700" aria-hidden="true" tabindex="-1"></a><span class="in">p = ggplot(rd, aes(x = x, y = y)) +</span></span>
<span id="cb86-701"><a href="#cb86-701" aria-hidden="true" tabindex="-1"></a><span class="in">  # geom_area(mapping = aes(x = x, y = y), fill = "red", alpha = 0.5) +</span></span>
<span id="cb86-702"><a href="#cb86-702" aria-hidden="true" tabindex="-1"></a><span class="in">  coord_fixed(ratio = 1) +</span></span>
<span id="cb86-703"><a href="#cb86-703" aria-hidden="true" tabindex="-1"></a><span class="in">  ylab(expression(TPR)) + xlab(expression(FPR)) +</span></span>
<span id="cb86-704"><a href="#cb86-704" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_bw()</span></span>
<span id="cb86-705"><a href="#cb86-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-706"><a href="#cb86-706" aria-hidden="true" tabindex="-1"></a><span class="in">p1 = p +</span></span>
<span id="cb86-707"><a href="#cb86-707" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(color = 2, lty = 2, linewidth = 0.75) +</span></span>
<span id="cb86-708"><a href="#cb86-708" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_text(aes(x = 0.5, y = 0.5, hjust = 0.5, vjust = -0.5, label = "random classifiers"), color = 2, size = 3, angle = 45) +</span></span>
<span id="cb86-709"><a href="#cb86-709" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point(data = classif, aes(x = x, y = y, color = classifier, shape = classifier), size = 3) +</span></span>
<span id="cb86-710"><a href="#cb86-710" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_text(data = classif[classif$classifier == "baseline",],</span></span>
<span id="cb86-711"><a href="#cb86-711" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(x = x, y = y, hjust = c(1.1, -0.1), vjust = c(0.5, 0.5)),</span></span>
<span id="cb86-712"><a href="#cb86-712" aria-hidden="true" tabindex="-1"></a><span class="in">    label = c("always predict positive class", "never predict positive class"),</span></span>
<span id="cb86-713"><a href="#cb86-713" aria-hidden="true" tabindex="-1"></a><span class="in">    color = 2, size = 3) +</span></span>
<span id="cb86-714"><a href="#cb86-714" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_text(data = classif[grepl("^C", classif$classifier), ],</span></span>
<span id="cb86-715"><a href="#cb86-715" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(x = x, y = y, hjust = c(0.5, 0.5, 0.5), vjust = c(-1, -1, -1)),</span></span>
<span id="cb86-716"><a href="#cb86-716" aria-hidden="true" tabindex="-1"></a><span class="in">    label = c("C1", "C2", "C3"),</span></span>
<span id="cb86-717"><a href="#cb86-717" aria-hidden="true" tabindex="-1"></a><span class="in">    color = c("C1" = "black", "C2" = "black", "C3" = "black"), #c("C1" = "gray70", "C2" = "gray50", "C3" = "gray30"),</span></span>
<span id="cb86-718"><a href="#cb86-718" aria-hidden="true" tabindex="-1"></a><span class="in">    size = 3) +</span></span>
<span id="cb86-719"><a href="#cb86-719" aria-hidden="true" tabindex="-1"></a><span class="in">  ggtitle("(a)") +</span></span>
<span id="cb86-720"><a href="#cb86-720" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_color_manual("classifier",</span></span>
<span id="cb86-721"><a href="#cb86-721" aria-hidden="true" tabindex="-1"></a><span class="in">    values = c("best" = 3, "baseline" = 2,</span></span>
<span id="cb86-722"><a href="#cb86-722" aria-hidden="true" tabindex="-1"></a><span class="in">      "C1" = "black", "C2" = "black",  "C3" = "black"</span></span>
<span id="cb86-723"><a href="#cb86-723" aria-hidden="true" tabindex="-1"></a><span class="in">        ))</span></span>
<span id="cb86-724"><a href="#cb86-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-725"><a href="#cb86-725" aria-hidden="true" tabindex="-1"></a><span class="in">dall = rbind(</span></span>
<span id="cb86-726"><a href="#cb86-726" aria-hidden="true" tabindex="-1"></a><span class="in">  cbind(d1, AUC = round(mean(d1$y), 2), classifier = "C1"),</span></span>
<span id="cb86-727"><a href="#cb86-727" aria-hidden="true" tabindex="-1"></a><span class="in">  cbind(d2, AUC = round(mean(d2$y), 2), classifier = "C2"),</span></span>
<span id="cb86-728"><a href="#cb86-728" aria-hidden="true" tabindex="-1"></a><span class="in">  cbind(d3, AUC = round(mean(d3$y), 2), classifier = "C3"),</span></span>
<span id="cb86-729"><a href="#cb86-729" aria-hidden="true" tabindex="-1"></a><span class="in">  cbind(classif[c(3, 1, 2), 1:2], AUC = 1, classifier = "best"),</span></span>
<span id="cb86-730"><a href="#cb86-730" aria-hidden="true" tabindex="-1"></a><span class="in">  cbind(rd, AUC = 0.5, classifier = "random")</span></span>
<span id="cb86-731"><a href="#cb86-731" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-732"><a href="#cb86-732" aria-hidden="true" tabindex="-1"></a><span class="in">dall$AUC = factor(dall$classifier, levels = c("best", "random", "C1", "C2", "C3"))</span></span>
<span id="cb86-733"><a href="#cb86-733" aria-hidden="true" tabindex="-1"></a><span class="in">#dall$AUC = factor(dall$AUC, levels = sort(unique(dall$AUC), decreasing = TRUE))</span></span>
<span id="cb86-734"><a href="#cb86-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-735"><a href="#cb86-735" aria-hidden="true" tabindex="-1"></a><span class="in">lab = c("best \n(AUC = 1)", "random \n(AUC = 0.5)", "C1 (AUC = 0.9)", "C2 (AUC = 0.75)", "C3 (AUC = 0.9)")</span></span>
<span id="cb86-736"><a href="#cb86-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-737"><a href="#cb86-737" aria-hidden="true" tabindex="-1"></a><span class="in">p2 = p +</span></span>
<span id="cb86-738"><a href="#cb86-738" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_text(aes(x = 0.5, y = 0.5, hjust = 0.5, vjust = -0.5, label = "baseline"), color = 2, size = 3, angle = 45) +</span></span>
<span id="cb86-739"><a href="#cb86-739" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dall, aes(x = x, y = y, lty = AUC, col = AUC), linewidth = 0.75) + ggtitle("(b)") +</span></span>
<span id="cb86-740"><a href="#cb86-740" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point(data = classif[grepl("^C", classif$classifier), ], aes(x = x, y = y, shape = classifier), size = 3) +</span></span>
<span id="cb86-741"><a href="#cb86-741" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_text(data = classif[grepl("^C", classif$classifier), ],</span></span>
<span id="cb86-742"><a href="#cb86-742" aria-hidden="true" tabindex="-1"></a><span class="in">    aes(x = x, y = y, hjust = c(0.5, 0.5, 0.5), vjust = c(-1, -1, -1)),</span></span>
<span id="cb86-743"><a href="#cb86-743" aria-hidden="true" tabindex="-1"></a><span class="in">    label = c("C1", "C2", "C3"),</span></span>
<span id="cb86-744"><a href="#cb86-744" aria-hidden="true" tabindex="-1"></a><span class="in">    color = c("C1" = "black", "C2" = "black", "C3" = "black"),</span></span>
<span id="cb86-745"><a href="#cb86-745" aria-hidden="true" tabindex="-1"></a><span class="in">    size = 3) +</span></span>
<span id="cb86-746"><a href="#cb86-746" aria-hidden="true" tabindex="-1"></a><span class="in">  ylim(c(0, 1)) +</span></span>
<span id="cb86-747"><a href="#cb86-747" aria-hidden="true" tabindex="-1"></a><span class="in">  guides(shape = "none") +</span></span>
<span id="cb86-748"><a href="#cb86-748" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_color_manual("ROC curve",</span></span>
<span id="cb86-749"><a href="#cb86-749" aria-hidden="true" tabindex="-1"></a><span class="in">    values = c(</span></span>
<span id="cb86-750"><a href="#cb86-750" aria-hidden="true" tabindex="-1"></a><span class="in">      "best" = 3,</span></span>
<span id="cb86-751"><a href="#cb86-751" aria-hidden="true" tabindex="-1"></a><span class="in">      "random" = 2,</span></span>
<span id="cb86-752"><a href="#cb86-752" aria-hidden="true" tabindex="-1"></a><span class="in">      "C1" = "gray70", "C2" = "gray70", "C3" = "gray70"),</span></span>
<span id="cb86-753"><a href="#cb86-753" aria-hidden="true" tabindex="-1"></a><span class="in">    labels = lab) +</span></span>
<span id="cb86-754"><a href="#cb86-754" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_linetype_manual("ROC curve",</span></span>
<span id="cb86-755"><a href="#cb86-755" aria-hidden="true" tabindex="-1"></a><span class="in">    values = c(</span></span>
<span id="cb86-756"><a href="#cb86-756" aria-hidden="true" tabindex="-1"></a><span class="in">      "best" = 3,</span></span>
<span id="cb86-757"><a href="#cb86-757" aria-hidden="true" tabindex="-1"></a><span class="in">      "random" = 2,</span></span>
<span id="cb86-758"><a href="#cb86-758" aria-hidden="true" tabindex="-1"></a><span class="in">      "C1" = 3, "C2" = 4, "C3" = 5),</span></span>
<span id="cb86-759"><a href="#cb86-759" aria-hidden="true" tabindex="-1"></a><span class="in">    labels = lab) +</span></span>
<span id="cb86-760"><a href="#cb86-760" aria-hidden="true" tabindex="-1"></a><span class="in">  NULL</span></span>
<span id="cb86-761"><a href="#cb86-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-762"><a href="#cb86-762" aria-hidden="true" tabindex="-1"></a><span class="in">#ggarrange(p1, p2, nrow = 1, ncol = 2)</span></span>
<span id="cb86-763"><a href="#cb86-763" aria-hidden="true" tabindex="-1"></a><span class="in"># p1 + geom_function(fun = function(x) fun(x, lambda = lambda1), mapping = aes(col = "0.91")) +</span></span>
<span id="cb86-764"><a href="#cb86-764" aria-hidden="true" tabindex="-1"></a><span class="in">#   geom_function(fun = function(x) fun(x, lambda = lambda2)) +</span></span>
<span id="cb86-765"><a href="#cb86-765" aria-hidden="true" tabindex="-1"></a><span class="in">#   geom_function(fun = function(x) funinv(x, lambda = lambda1))</span></span>
<span id="cb86-766"><a href="#cb86-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-767"><a href="#cb86-767" aria-hidden="true" tabindex="-1"></a><span class="in">p1 + p2 &amp; theme(plot.margin = grid::unit(c(0, 0, 0, 0), "mm"))</span></span>
<span id="cb86-768"><a href="#cb86-768" aria-hidden="true" tabindex="-1"></a><span class="in">#p1 + p2 &amp; theme(legend.position = "bottom")</span></span>
<span id="cb86-769"><a href="#cb86-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-770"><a href="#cb86-770" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-771"><a href="#cb86-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-772"><a href="#cb86-772" aria-hidden="true" tabindex="-1"></a>Now consider classifiers that predict probabilities instead of discrete classes.</span>
<span id="cb86-773"><a href="#cb86-773" aria-hidden="true" tabindex="-1"></a>Using different thresholds to cut off predicted probabilities and assign them to the positive and negative class will lead to different TPRs and FPRs and by plotting these values across different thresholds we can characterize the behavior of a binary classifier -- this is the ROC curve.</span>
<span id="cb86-774"><a href="#cb86-774" aria-hidden="true" tabindex="-1"></a>For example, we can use the previous <span class="in">`r ref("Prediction")`</span> object to compute all possible TPR and FPR combinations by thresholding the predicted probabilities across all possible thresholds, which is exactly what <span class="in">`mlr3viz::autoplot.PredictionClassif`</span> will do when <span class="in">`type = "roc"`</span> is selected:</span>
<span id="cb86-775"><a href="#cb86-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-776"><a href="#cb86-776" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-055}</span></span>
<span id="cb86-777"><a href="#cb86-777" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb86-778"><a href="#cb86-778" aria-hidden="true" tabindex="-1"></a><span class="in">#| cache: false</span></span>
<span id="cb86-779"><a href="#cb86-779" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(prediction, type = "roc")</span></span>
<span id="cb86-780"><a href="#cb86-780" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-781"><a href="#cb86-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-782"><a href="#cb86-782" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.width = "70%"}</span></span>
<span id="cb86-783"><a href="#cb86-783" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-basics-roc-ranger</span></span>
<span id="cb86-784"><a href="#cb86-784" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "ROC-curve based on the `german_credit` dataset and the `classif.ranger` random forest learner. Recall FPR = $1 -$ Specificity and TPR = Sensitivity."</span></span>
<span id="cb86-785"><a href="#cb86-785" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: ROC curve with "1 - Specificity" on x-axis (between 0-1) and "Sensitivity" on y-axis (between 0-1). There is a line from around (0,0) to (0.3,0.75) to (1, 1).</span></span>
<span id="cb86-786"><a href="#cb86-786" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-787"><a href="#cb86-787" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb86-788"><a href="#cb86-788" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb86-789"><a href="#cb86-789" aria-hidden="true" tabindex="-1"></a><span class="in">plt = ggplot2::last_plot()</span></span>
<span id="cb86-790"><a href="#cb86-790" aria-hidden="true" tabindex="-1"></a><span class="in">plt = plt + ggplot2::scale_color_grey()</span></span>
<span id="cb86-791"><a href="#cb86-791" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt)</span></span>
<span id="cb86-792"><a href="#cb86-792" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-793"><a href="#cb86-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-794"><a href="#cb86-794" aria-hidden="true" tabindex="-1"></a>A natural performance measure that can be derived from the ROC curve is the <span class="in">`r index('area under the curve', "AUC", lower = FALSE, aside = TRUE)`</span> (AUC), implemented in <span class="in">`msr("classif.auc")`</span>.</span>
<span id="cb86-795"><a href="#cb86-795" aria-hidden="true" tabindex="-1"></a>The AUC can be interpreted as the probability that a randomly chosen positive instance has a higher predicted probability of belonging to the positive class than a randomly chosen negative instance.</span>
<span id="cb86-796"><a href="#cb86-796" aria-hidden="true" tabindex="-1"></a>Therefore, higher values (closer to $1$) indicate better performance.</span>
<span id="cb86-797"><a href="#cb86-797" aria-hidden="true" tabindex="-1"></a>Random classifiers (such as the featureless baseline) will always have an AUC of (approximately, when evaluated empirically) 0.5 (see @fig-roc, panel (b)).</span>
<span id="cb86-798"><a href="#cb86-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-801"><a href="#cb86-801" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb86-802"><a href="#cb86-802" aria-hidden="true" tabindex="-1"></a>prediction<span class="sc">$</span><span class="fu">score</span>(<span class="fu">msr</span>(<span class="st">"classif.auc"</span>))</span>
<span id="cb86-803"><a href="#cb86-803" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-804"><a href="#cb86-804" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo = FALSE}</span></span>
<span id="cb86-805"><a href="#cb86-805" aria-hidden="true" tabindex="-1"></a><span class="in">x = prediction$score(msr("classif.auc"))</span></span>
<span id="cb86-806"><a href="#cb86-806" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-807"><a href="#cb86-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-808"><a href="#cb86-808" aria-hidden="true" tabindex="-1"></a>Evaluating our random forest on <span class="in">`tsk("german_credit")`</span> results in an AUC of around <span class="in">`r round(x, 2)`</span>, which is acceptable but could be better.</span>
<span id="cb86-809"><a href="#cb86-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-810"><a href="#cb86-810" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb86-811"><a href="#cb86-811" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multiclass ROC and AUC</span></span>
<span id="cb86-812"><a href="#cb86-812" aria-hidden="true" tabindex="-1"></a>Extensions of ROC analysis for multiclass classifiers exist <span class="co">[</span><span class="ot">see e.g., @hand2001simple</span><span class="co">]</span> but we only cover the more common binary classification case in this book.</span>
<span id="cb86-813"><a href="#cb86-813" aria-hidden="true" tabindex="-1"></a>Generalizations of the AUC measure to multiclass classification are implemented in <span class="in">`mlr3`</span>, see <span class="in">`msr("classif.mauc_au1p")`</span>.</span>
<span id="cb86-814"><a href="#cb86-814" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb86-815"><a href="#cb86-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-816"><a href="#cb86-816" aria-hidden="true" tabindex="-1"></a>We can also plot the <span class="in">`r index('precision-recall curve', aside = TRUE)`</span> (PRC) which visualizes the PPV/precision\index{positive predictive value} vs. TPR/recall\index{true positive rate}.</span>
<span id="cb86-817"><a href="#cb86-817" aria-hidden="true" tabindex="-1"></a>The main difference between ROC curves and PR curves is that the number of true-negatives are ignored in the latter.</span>
<span id="cb86-818"><a href="#cb86-818" aria-hidden="true" tabindex="-1"></a>This can be useful in imbalanced populations where the positive class is rare, and where a classifier with high TPR may still not be very informative and have low PPV.</span>
<span id="cb86-819"><a href="#cb86-819" aria-hidden="true" tabindex="-1"></a>See @davis2006relationship for a detailed discussion about the relationship between the PRC and ROC curves.</span>
<span id="cb86-820"><a href="#cb86-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-821"><a href="#cb86-821" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-056}</span></span>
<span id="cb86-822"><a href="#cb86-822" aria-hidden="true" tabindex="-1"></a><span class="in">#| output: false</span></span>
<span id="cb86-823"><a href="#cb86-823" aria-hidden="true" tabindex="-1"></a><span class="in">#| cache: false</span></span>
<span id="cb86-824"><a href="#cb86-824" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(prediction, type = "prc")</span></span>
<span id="cb86-825"><a href="#cb86-825" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-826"><a href="#cb86-826" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-827"><a href="#cb86-827" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.width = "70%"}</span></span>
<span id="cb86-828"><a href="#cb86-828" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: 'Precision-Recall curve based on `tsk("german_credit")` and `lrn("classif.ranger")`.'</span></span>
<span id="cb86-829"><a href="#cb86-829" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-basics-prc-ranger</span></span>
<span id="cb86-830"><a href="#cb86-830" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: 'Line curve with "Recall" on x-axis (between 0-1) and "Precision" on y-axis (between 0-1). There is a horizontal line through around y=0.74. There is also a line decreasing from (0,1) to (1,0.74).'</span></span>
<span id="cb86-831"><a href="#cb86-831" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-832"><a href="#cb86-832" aria-hidden="true" tabindex="-1"></a><span class="in">#| warning: false</span></span>
<span id="cb86-833"><a href="#cb86-833" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb86-834"><a href="#cb86-834" aria-hidden="true" tabindex="-1"></a><span class="in">plt = ggplot2::last_plot()</span></span>
<span id="cb86-835"><a href="#cb86-835" aria-hidden="true" tabindex="-1"></a><span class="in">plt = plt + ggplot2::scale_color_grey()</span></span>
<span id="cb86-836"><a href="#cb86-836" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt)</span></span>
<span id="cb86-837"><a href="#cb86-837" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-838"><a href="#cb86-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-839"><a href="#cb86-839" aria-hidden="true" tabindex="-1"></a>Another useful way to think about the performance of a classifier is to visualize the relationship of a performance metric over varying thresholds, for example, see @fig-basics-fpracc-ranger to inspect the FPR and accuracy across all possible thresholds:</span>
<span id="cb86-840"><a href="#cb86-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-841"><a href="#cb86-841" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-057}</span></span>
<span id="cb86-842"><a href="#cb86-842" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb86-843"><a href="#cb86-843" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(prediction, type = "threshold", measure = msr("classif.fpr"))</span></span>
<span id="cb86-844"><a href="#cb86-844" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(prediction, type = "threshold", measure = msr("classif.acc"))</span></span>
<span id="cb86-845"><a href="#cb86-845" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-846"><a href="#cb86-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-847"><a href="#cb86-847" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-057-1}</span></span>
<span id="cb86-848"><a href="#cb86-848" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-basics-fpracc-ranger</span></span>
<span id="cb86-849"><a href="#cb86-849" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: 'Comparing threshold and FPR (left) with threshold and accuracy (right) for the random forest trained on `tsk("german_credit")`.'</span></span>
<span id="cb86-850"><a href="#cb86-850" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: 'Two line graphs, both with "Probability Threshold" on x-axis from 0-1. Left: "classif.fpr" on y-axis. Line slowly decreases from (0,1) to (1,0). Right: "classif.acc" on y-axis. Line travels from (0,0.7) to (0.25,0.7) to (0.4,0.75) to (1, 0.3).'</span></span>
<span id="cb86-851"><a href="#cb86-851" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-subcap:</span></span>
<span id="cb86-852"><a href="#cb86-852" aria-hidden="true" tabindex="-1"></a><span class="in">#|  - FPR</span></span>
<span id="cb86-853"><a href="#cb86-853" aria-hidden="true" tabindex="-1"></a><span class="in">#|  - Accuracy</span></span>
<span id="cb86-854"><a href="#cb86-854" aria-hidden="true" tabindex="-1"></a><span class="in">#| layout-ncol: 2</span></span>
<span id="cb86-855"><a href="#cb86-855" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-856"><a href="#cb86-856" aria-hidden="true" tabindex="-1"></a><span class="in">plt1 = autoplot(prediction, type = "threshold", measure = msr("classif.fpr"))</span></span>
<span id="cb86-857"><a href="#cb86-857" aria-hidden="true" tabindex="-1"></a><span class="in">plt1$layers[[1]]$aes_params$colour = "grey30"</span></span>
<span id="cb86-858"><a href="#cb86-858" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt1)</span></span>
<span id="cb86-859"><a href="#cb86-859" aria-hidden="true" tabindex="-1"></a><span class="in">plt2 = autoplot(prediction, type = "threshold", measure = msr("classif.acc"))</span></span>
<span id="cb86-860"><a href="#cb86-860" aria-hidden="true" tabindex="-1"></a><span class="in">plt2$layers[[1]]$aes_params$colour = "grey30"</span></span>
<span id="cb86-861"><a href="#cb86-861" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt2)</span></span>
<span id="cb86-862"><a href="#cb86-862" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-863"><a href="#cb86-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-864"><a href="#cb86-864" aria-hidden="true" tabindex="-1"></a>This visualization would show us that changing the threshold from the default 0.5 to a higher value like 0.7 would greatly reduce the FPR while reducing accuracy by only a few percentage points.</span>
<span id="cb86-865"><a href="#cb86-865" aria-hidden="true" tabindex="-1"></a>Depending on the problem at hand, this might be a perfectly desirable trade-off.</span>
<span id="cb86-866"><a href="#cb86-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-867"><a href="#cb86-867" aria-hidden="true" tabindex="-1"></a>These visualizations are also available for <span class="in">`r ref("ResampleResult")`</span> objects.</span>
<span id="cb86-868"><a href="#cb86-868" aria-hidden="true" tabindex="-1"></a>In this case, the predictions of individual resampling iterations are merged before calculating a ROC or PR curve (micro averaged):</span>
<span id="cb86-869"><a href="#cb86-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-870"><a href="#cb86-870" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-058}</span></span>
<span id="cb86-871"><a href="#cb86-871" aria-hidden="true" tabindex="-1"></a><span class="in">#| eval: false</span></span>
<span id="cb86-872"><a href="#cb86-872" aria-hidden="true" tabindex="-1"></a><span class="in">rr = resample(</span></span>
<span id="cb86-873"><a href="#cb86-873" aria-hidden="true" tabindex="-1"></a><span class="in">  task = tsk("german_credit"),</span></span>
<span id="cb86-874"><a href="#cb86-874" aria-hidden="true" tabindex="-1"></a><span class="in">  learner = lrn("classif.ranger", predict_type = "prob"),</span></span>
<span id="cb86-875"><a href="#cb86-875" aria-hidden="true" tabindex="-1"></a><span class="in">  resampling = rsmp("cv", folds = 5)</span></span>
<span id="cb86-876"><a href="#cb86-876" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-877"><a href="#cb86-877" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(rr, type = "roc")</span></span>
<span id="cb86-878"><a href="#cb86-878" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(rr, type = "prc")</span></span>
<span id="cb86-879"><a href="#cb86-879" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-880"><a href="#cb86-880" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-058-1}</span></span>
<span id="cb86-881"><a href="#cb86-881" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-basics-rocpr-ranger</span></span>
<span id="cb86-882"><a href="#cb86-882" aria-hidden="true" tabindex="-1"></a><span class="in">#| layout-ncol: 2</span></span>
<span id="cb86-883"><a href="#cb86-883" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-subcap:</span></span>
<span id="cb86-884"><a href="#cb86-884" aria-hidden="true" tabindex="-1"></a><span class="in">#|  - ROC</span></span>
<span id="cb86-885"><a href="#cb86-885" aria-hidden="true" tabindex="-1"></a><span class="in">#|  - PR Curve</span></span>
<span id="cb86-886"><a href="#cb86-886" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: 'Comparing ROC (left) and PR curve (right) for a random forest trained on `tsk("german_credit")`.'</span></span>
<span id="cb86-887"><a href="#cb86-887" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: 'Two line graphs. Left is ROC curve with the "best" point close to (0.25, 0.75). Right is PR curve ending at 0.74.'</span></span>
<span id="cb86-888"><a href="#cb86-888" aria-hidden="true" tabindex="-1"></a><span class="in">#| echo: false</span></span>
<span id="cb86-889"><a href="#cb86-889" aria-hidden="true" tabindex="-1"></a><span class="in">#| message: false</span></span>
<span id="cb86-890"><a href="#cb86-890" aria-hidden="true" tabindex="-1"></a><span class="in">rr = resample(</span></span>
<span id="cb86-891"><a href="#cb86-891" aria-hidden="true" tabindex="-1"></a><span class="in">  task = tsk("german_credit"),</span></span>
<span id="cb86-892"><a href="#cb86-892" aria-hidden="true" tabindex="-1"></a><span class="in">  learner = lrn("classif.ranger", predict_type = "prob"),</span></span>
<span id="cb86-893"><a href="#cb86-893" aria-hidden="true" tabindex="-1"></a><span class="in">  resampling = rsmp("cv", folds = 5)</span></span>
<span id="cb86-894"><a href="#cb86-894" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-895"><a href="#cb86-895" aria-hidden="true" tabindex="-1"></a><span class="in">plt1 = autoplot(rr, type = "roc")</span></span>
<span id="cb86-896"><a href="#cb86-896" aria-hidden="true" tabindex="-1"></a><span class="in">plt1 = plt1 + ggplot2::scale_fill_grey() + ggplot2::scale_color_grey()</span></span>
<span id="cb86-897"><a href="#cb86-897" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt1)</span></span>
<span id="cb86-898"><a href="#cb86-898" aria-hidden="true" tabindex="-1"></a><span class="in">plt2 = autoplot(rr, type = "prc")</span></span>
<span id="cb86-899"><a href="#cb86-899" aria-hidden="true" tabindex="-1"></a><span class="in">plt2 = plt2 + ggplot2::scale_fill_grey() + ggplot2::scale_color_grey()</span></span>
<span id="cb86-900"><a href="#cb86-900" aria-hidden="true" tabindex="-1"></a><span class="in">print(plt2)</span></span>
<span id="cb86-901"><a href="#cb86-901" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-902"><a href="#cb86-902" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-903"><a href="#cb86-903" aria-hidden="true" tabindex="-1"></a>Finally, we can visualize ROC/PR curves for a <span class="in">`r ref("BenchmarkResult")`</span> to compare multiple learners on the same <span class="in">`r ref("Task")`</span>:</span>
<span id="cb86-904"><a href="#cb86-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-905"><a href="#cb86-905" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-059-evalF, eval = FALSE}</span></span>
<span id="cb86-906"><a href="#cb86-906" aria-hidden="true" tabindex="-1"></a><span class="in">library(patchwork)</span></span>
<span id="cb86-907"><a href="#cb86-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-908"><a href="#cb86-908" aria-hidden="true" tabindex="-1"></a><span class="in">design = benchmark_grid(</span></span>
<span id="cb86-909"><a href="#cb86-909" aria-hidden="true" tabindex="-1"></a><span class="in">  tasks = tsk("german_credit"),</span></span>
<span id="cb86-910"><a href="#cb86-910" aria-hidden="true" tabindex="-1"></a><span class="in">  learners = lrns(c("classif.rpart", "classif.ranger"),</span></span>
<span id="cb86-911"><a href="#cb86-911" aria-hidden="true" tabindex="-1"></a><span class="in">    predict_type = "prob"),</span></span>
<span id="cb86-912"><a href="#cb86-912" aria-hidden="true" tabindex="-1"></a><span class="in">  resamplings = rsmp("cv", folds = 5)</span></span>
<span id="cb86-913"><a href="#cb86-913" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-914"><a href="#cb86-914" aria-hidden="true" tabindex="-1"></a><span class="in">bmr = benchmark(design)</span></span>
<span id="cb86-915"><a href="#cb86-915" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(bmr, type = "roc") + autoplot(bmr, type = "prc") +</span></span>
<span id="cb86-916"><a href="#cb86-916" aria-hidden="true" tabindex="-1"></a><span class="in">  plot_layout(guides = "collect")</span></span>
<span id="cb86-917"><a href="#cb86-917" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-918"><a href="#cb86-918" aria-hidden="true" tabindex="-1"></a><span class="in">```{r performance-059-evalT, echo = FALSE, fig.width = 11}</span></span>
<span id="cb86-919"><a href="#cb86-919" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-basics-rocpr-bmr</span></span>
<span id="cb86-920"><a href="#cb86-920" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: 'Comparing random forest (green) and decision tree (purple) using ROC and PR Curves.'</span></span>
<span id="cb86-921"><a href="#cb86-921" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-alt: 'Two line graphs, each with two lines for decision tree and random forest. Left is ROC curve showing random forest has consistently better TPR/FPR trade-off. Right is PR Curve showing random forest has better Precision/Recall trade-off.'</span></span>
<span id="cb86-922"><a href="#cb86-922" aria-hidden="true" tabindex="-1"></a><span class="in">library(patchwork)</span></span>
<span id="cb86-923"><a href="#cb86-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-924"><a href="#cb86-924" aria-hidden="true" tabindex="-1"></a><span class="in">design = benchmark_grid(</span></span>
<span id="cb86-925"><a href="#cb86-925" aria-hidden="true" tabindex="-1"></a><span class="in">  tasks = tsk("german_credit"),</span></span>
<span id="cb86-926"><a href="#cb86-926" aria-hidden="true" tabindex="-1"></a><span class="in">  learners = lrns(c("classif.rpart", "classif.ranger"),</span></span>
<span id="cb86-927"><a href="#cb86-927" aria-hidden="true" tabindex="-1"></a><span class="in">    predict_type = "prob"),</span></span>
<span id="cb86-928"><a href="#cb86-928" aria-hidden="true" tabindex="-1"></a><span class="in">  resamplings = rsmp("cv", folds = 5)</span></span>
<span id="cb86-929"><a href="#cb86-929" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb86-930"><a href="#cb86-930" aria-hidden="true" tabindex="-1"></a><span class="in">bmr = benchmark(design)</span></span>
<span id="cb86-931"><a href="#cb86-931" aria-hidden="true" tabindex="-1"></a><span class="in">fig = magick::image_graph(width = 1500, height = 1000, res = 200)</span></span>
<span id="cb86-932"><a href="#cb86-932" aria-hidden="true" tabindex="-1"></a><span class="in">autoplot(bmr, type = "roc") + autoplot(bmr, type = "prc") +</span></span>
<span id="cb86-933"><a href="#cb86-933" aria-hidden="true" tabindex="-1"></a><span class="in">  plot_layout(guides = "collect")</span></span>
<span id="cb86-934"><a href="#cb86-934" aria-hidden="true" tabindex="-1"></a><span class="in">invisible(dev.off())</span></span>
<span id="cb86-935"><a href="#cb86-935" aria-hidden="true" tabindex="-1"></a><span class="in">magick::image_trim(fig)</span></span>
<span id="cb86-936"><a href="#cb86-936" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb86-937"><a href="#cb86-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-938"><a href="#cb86-938" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb86-939"><a href="#cb86-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-940"><a href="#cb86-940" aria-hidden="true" tabindex="-1"></a>In this chapter, we learned how to estimate the generalization performance of a model via resampling strategies, from holdout to cross-validation and bootstrap, and how to automate the comparison of multiple learners in benchmark experiments.</span>
<span id="cb86-941"><a href="#cb86-941" aria-hidden="true" tabindex="-1"></a>We also covered the basics of performance measures for binary classification, including the confusion matrix, ROC analysis, and precision-recall curves.</span>
<span id="cb86-942"><a href="#cb86-942" aria-hidden="true" tabindex="-1"></a>These topics are fundamental in supervised learning and will continue to be built upon throughout this book.</span>
<span id="cb86-943"><a href="#cb86-943" aria-hidden="true" tabindex="-1"></a>In particular, @sec-optimization utilizes evaluation in automated model tuning to improve performance, in @sec-large-benchmarking  we look at large benchmarks and their statistical analysis, and in @sec-special we will take a look at specialized tasks that require different resampling strategies.</span>
<span id="cb86-944"><a href="#cb86-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-945"><a href="#cb86-945" aria-hidden="true" tabindex="-1"></a>| Class | Constructor/Function | Fields/Methods |</span>
<span id="cb86-946"><a href="#cb86-946" aria-hidden="true" tabindex="-1"></a>| ---- | ----- | -------- |</span>
<span id="cb86-947"><a href="#cb86-947" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("PredictionClassif")`</span> | <span class="in">`classif_lrn$predict()`</span> | <span class="in">`r ref("mlr3measures::confusion_matrix()")`</span>; <span class="in">`autoplot(some_prediction_classif, type = "roc")`</span> |</span>
<span id="cb86-948"><a href="#cb86-948" aria-hidden="true" tabindex="-1"></a>| - | <span class="in">`r ref("partition()")`</span> | - |</span>
<span id="cb86-949"><a href="#cb86-949" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("Resampling")`</span> | <span class="in">`r ref("rsmp()")`</span> | <span class="in">`$instantiate()`</span> |</span>
<span id="cb86-950"><a href="#cb86-950" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("ResampleResult")`</span> | <span class="in">`r ref("resample()")`</span> | <span class="in">`$score()`</span>; <span class="in">`$aggregate()`</span>; <span class="in">`$predictions()`</span>; <span class="in">`as_benchmark_result()`</span>; <span class="in">`autoplot(some_resample_result, type = "roc")`</span> |</span>
<span id="cb86-951"><a href="#cb86-951" aria-hidden="true" tabindex="-1"></a>| - | <span class="in">`r ref("benchmark_grid()")`</span> | - |</span>
<span id="cb86-952"><a href="#cb86-952" aria-hidden="true" tabindex="-1"></a>| <span class="in">`r ref("BenchmarkResult")`</span> | <span class="in">`r ref("benchmark()")`</span> | <span class="in">`$aggregate()`</span>; <span class="in">`$resample_result()`</span>; <span class="in">`$score()`</span>; <span class="in">`autoplot(some_benchmark_result, type = "roc")`</span> |</span>
<span id="cb86-953"><a href="#cb86-953" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-954"><a href="#cb86-954" aria-hidden="true" tabindex="-1"></a>: Important classes and functions covered in this chapter with underlying class (if applicable), class constructor or function, and important class fields and methods (if applicable). {#tbl-api-performance}</span>
<span id="cb86-955"><a href="#cb86-955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-956"><a href="#cb86-956" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercises</span></span>
<span id="cb86-957"><a href="#cb86-957" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-958"><a href="#cb86-958" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Apply a repeated cross-validation resampling strategy on <span class="in">`tsk("mtcars")`</span> and evaluate the performance of <span class="in">`lrn("regr.rpart")`</span>.</span>
<span id="cb86-959"><a href="#cb86-959" aria-hidden="true" tabindex="-1"></a>Use five repeats of three folds each.</span>
<span id="cb86-960"><a href="#cb86-960" aria-hidden="true" tabindex="-1"></a>Calculate the MSE for each iteration and visualize the result.</span>
<span id="cb86-961"><a href="#cb86-961" aria-hidden="true" tabindex="-1"></a>Finally, calculate the aggregated performance score.</span>
<span id="cb86-962"><a href="#cb86-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-963"><a href="#cb86-963" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Use <span class="in">`tsk("spam")`</span> and five-fold CV to benchmark <span class="in">`lrn("classif.ranger")`</span>, <span class="in">`lrn("classif.log_reg")`</span>, and <span class="in">`lrn("classif.xgboost", nrounds = 100)`</span> with respect to AUC.</span>
<span id="cb86-964"><a href="#cb86-964" aria-hidden="true" tabindex="-1"></a>Which learner appears to perform best? How confident are you in your conclusion?</span>
<span id="cb86-965"><a href="#cb86-965" aria-hidden="true" tabindex="-1"></a>Think about the stability of results and investigate this by re-rerunning the experiment with different seeds.</span>
<span id="cb86-966"><a href="#cb86-966" aria-hidden="true" tabindex="-1"></a>What can be done to improve this?</span>
<span id="cb86-967"><a href="#cb86-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-968"><a href="#cb86-968" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>A colleague reports a 93.1% classification accuracy using <span class="in">`lrn("classif.rpart")`</span> on <span class="in">`tsk("penguins_simple")`</span>.</span>
<span id="cb86-969"><a href="#cb86-969" aria-hidden="true" tabindex="-1"></a>You want to reproduce their results and ask them about their resampling strategy.</span>
<span id="cb86-970"><a href="#cb86-970" aria-hidden="true" tabindex="-1"></a>They said they used a custom three-fold CV with folds assigned as <span class="in">`factor(task$row_ids %% 3)`</span>.</span>
<span id="cb86-971"><a href="#cb86-971" aria-hidden="true" tabindex="-1"></a>See if you can reproduce their results.</span>
<span id="cb86-972"><a href="#cb86-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-973"><a href="#cb86-973" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>(*) Program your own ROC plotting function without using <span class="in">`mlr3`</span>'s <span class="in">`autoplot()`</span> function. The signature of your function should be <span class="in">`my_roc_plot(task, learner, train_indices, test_indices)`</span>.</span>
<span id="cb86-974"><a href="#cb86-974" aria-hidden="true" tabindex="-1"></a>  Your function should use the <span class="in">`$set_threshold()`</span> method of  <span class="in">`Prediction`</span>, as well as <span class="in">`mlr3measures`</span>.</span>
<span id="cb86-975"><a href="#cb86-975" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-976"><a href="#cb86-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-977"><a href="#cb86-977" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb86-978"><a href="#cb86-978" aria-hidden="true" tabindex="-1"></a><span class="in">`r citeas(chapter)`</span></span>
<span id="cb86-979"><a href="#cb86-979" aria-hidden="true" tabindex="-1"></a>:::</span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>All content licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> <br> © Bernd Bischl, Raphael Sonabend, Lars Kotthoff, Michel Lang.</p>
</div>   
    <div class="nav-footer-center">
<p><a href="https://mlr-org.com">Website</a> | <a href="https://github.com/mlr-org/mlr3book">GitHub</a> | <a href="https://mlr-org.com/gallery">Gallery</a> | <a href="https://lmmisld-lmu-stats-slds.srv.mwn.de/mlr_invite/">Mattermost</a></p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/mlr-org/mlr3book/edit/main/book/chapters/chapter3/evaluation_and_benchmarking.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/mlr-org/mlr3book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/mlr-org/mlr3book/blob/main/book/chapters/chapter3/evaluation_and_benchmarking.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>


<script src="../../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>